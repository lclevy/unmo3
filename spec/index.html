<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  
  <title>unofficial MO3 format description</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta content="MO3 format;mod format;module mp3;compressed module;file format;mo3 decompression;mo3 decoding" name="KEYWORDS">
  <meta content="the unofficial MO3 format description, with source code (GPL)" name="DESCRIPTION">
  <meta content="home page" name="CATEGORY">
  
  <style type="text/css">
.mo3 { color: rgb(255, 102, 0);
font-weight: normal;
font-style: normal;
text-transform: none;
text-align: left;
}
  </style>
</head>


<body>


<center>
<h1>The unofficial MO3 format description
</h1>
<h3>open source MO3 decompression and decoding support (but not playback)</h3>
</center>


<hr>News:
<ul>
  <li>2015Nov07 : updated specification by Johannes Schultz
  <li>2014May21 : code and specification pushed to <a href="https://github.com/lclevy/unmo3">Github</a>, to ease third party contributions (Hi Johannes Schultz)
  <li>2009Jul19 : v2.4 MO3 encoder updates: code updated to v0.6, and specification updated to 0.91. </li>
  <li>2006feb26 : unmo3 <b>source code</b> v0.5 is released (for technical people only). See section 4. and <a href="README.txt">Readme</a>. </li>
  <li>2006feb15 : format descriptions updates (infos about IT MIDI macros and instruments envelopes from Ian Luck) </li>
  <li>2006feb05 : the unpack algorithms source code (5 functions) is released. The unpack algorithms are explained. </li>
</ul>


<hr>
<h3>Version 0.92<br>
May 18th, 2014<br>
<img src="em.png">
</h3>


<h2>0. Credits</h2>

<ul>
  <li>Laurent Laubin for the PEtite decompression </li>
  <li>Matthew T. Russotto for the unpack compression explanation </li>
  <li>Ian Luck for answering questions about missing parts of thespec: IT macros, IT instruments structure, modules flags, IT fields of samples, plus some others... </li>
  <li>Stuart for initial discussion about the unpack compression.</li>
  <li>Johannes Schultz for further information on the format</li>
</ul>



<h2>1. Introduction</h2>


This description is applicable to mo3 encoder v1.8, v2.1, v2.2 and v2.4.
<h3>1.1 Overview</h3>


The MO3 format means "MOdule with MP3", because the main initial idea
was to reduce the size of
a module (in .mod, IT, XM) by compressing the samples using MPEG audio
layer 3.
<p>This format has been created by Ian Luck (<a href="http://www.un4seen.com">http://www.un4seen.com/</a>).
</p>


<p>But not only the samples are compressed, but also the music
data, containing mainly notes, instruments number
and effects, as well as instruments information. <br>


And a lot of effort has been used to reduce the size of this part. Then
a specific lossless compression is applied on music data.
</p>


<p>The samples can be compressed using OGG, MP3, and 2 kind of
specific lossless algorithms.
</p>


<p>We can define "compression" a scheme which detects all kind
repetition in some data, then encodes these repetition in a more
compact way. This principle is very well applied in MO3 for music data
encoding.
</p>


<h3>1.2 The music data size reduction</h3>


The first idea of the MO3 encoder is to parse the music data and detect
unused samples, then they are removed from the module.
<p>When composing a module, musicians often cut and paste the
content of a channel (later called a "voice") from one pattern
to another one : for example drums, and bass. So this kind of
repetition is detected by the encoder : a list of unique voice is
built, then the patterns are encoded using pointers onto these unique
voice data. This idea is used in <a href="mtm.txt">mtm</a>
format.<br>


This is very efficient especially for the "empty" voice : for example
in a module with 4 channels, often only 3 voices are used per pattern.
So the "empty" voice is repeated a lot of time.
</p>


<p>In a voice, one row can be repeated several times. This is
true for the empty row. This kind of repetition is detected and
stored in a compact way.
</p>


<p>The last size optimisation is how the row in a voice data is
encoded, using a list of type/value items.
</p>



<h3>1.3 The sample delta encodings</h3>


Digitized audio data are generally signed values stored in 8bits or
16bits. If directly compressed using general purpose
lossless compression algorithms, best result are about 10% of
reduction, which is poor.<br>

Audio samples are very random signals, so with few
repetitions.<br>

But the successive values are close to each other, so a good idea is
first encode them as delta values, (the first being 0 for example)
before compression. This is done in the 'delta' version of the MO3
lossless packers, and in XM modules.<br>

But there is more smart as the mathematical slope of audio data is
often constant : encode the error for the next predicted delta, instead
of directly
the delta value. Then the 'prediction' is adjusted with the error : so
the prediction is converging to the right 'next' delta value.<br>


This method is more efficient than simple delta one, especially on 16
bits data.


<h2>2. The file format</h2>


<h3>2.1 Compressed form</h3>


0x10 is the notation of an hexadecimal value (16 in decimal)<br>
short (2 bytes) and long (4 bytes) are stored in file in little endian order (intel x86)

<table border="1" cellpadding="2">
  <tbody>
    <tr>
      <td> Address </td>
      <td> Length </td>
      <td> Type </td>
      <td> Description</td>
    </tr>
    <tr>
      <td> 0x0000 </td>
      <td> 3 </td>
      <td> char </td>
      <td> "MO3"</td>
    </tr>
    <tr>
      <td> 0x0003 </td>
      <td> 1 </td>
      <td> byte </td>
      <td> version (0 with mp3 and lossless, 4 with v2.1, 1 with
ogg) related with sample compression, 4 should means "with no LAME header".<br> 3 means v2.2 and 5 v2.4 </td>

    </tr>
    <tr>
      <td> 0x0004 </td>
      <td> 1 </td>
      <td> long </td>
      <td> uncompressed length of header (music data) </td>
    </tr>
  </tbody>
</table>
Encoder version 2.2 and earlier (version == 0, 1, 3 or 4):
<table border="1" cellpadding="2">
  <tbody>
    <tr>
      <td> 0x0008 </td>
      <td> computed </td>
      <td> byte[] </td>
      <td> compressed music data (see section 2.2 - 2.4) </td>
    </tr>
    <tr>
      <td> computed </td>
      <td> computed </td>
      <td> byte[] </td>
      <td> samples, compressed or not, using lossless, mp3 or OGG
      </td>
    </tr>
  
  </tbody>
</table>
Encoder version 2.4 (version &ge; 5):
<table border="1" cellpadding="2">
  <tbody>
    <tr>
      <td> 0x0008 </td>
      <td> 1 </td>
      <td> long </td>
      <td> length of compressed data (sample data starts at this value + 12) </td>
    </tr>  
    <tr>
      <td> 0x000c </td>
      <td> computed </td>
      <td> byte[] </td>
      <td> compressed music data (see section 2.2 - 2.4) </td>
    </tr>
    <tr>
      <td> computed </td>
      <td> computed </td>
      <td> byte[] </td>
      <td> samples, compressed or not, using lossless, mp3 or OGG
      </td>
    </tr>
  
  </tbody>
</table>

<h3>2.2 The music data decompression algorithm</h3>


Here is Matthew explanation:
<p>"The first byte is always uncompressed. After that, you've got
two interleaved streams of control bytes and data bytes. The control
bytes are read by the shift_dl routine. <br>

In the unpack routine, the control bits are read most-significant first. <br>

A zero bit indicates "uncompressed byte". A one bit indicates compressed data. <br>

The next two control bits control which kind of compression <br>

-- if they are '00' it's LZ with the same (relative) pointer as a previous LZ. <br>

The next two bits of the control stream are the length, unless they are both zero. </p>

<p>If they are both zero, the true length minus 2 is encoded in
the control stream, two bits per bit. <br>

The first bit in each pair is the actual data, the second bit is 0 on
the last pair.
</p>

<p>If the first control bits are '11', '10' or '01', then the LZ
pointer is in the control stream. <br>

The most significant bit of the pointer is a '1', then the next most
significant bits of the pointer are read from the control stream two
bits at a time as described above (including the initial 11 or 01 or
10). Then 3 is subtracted from that value and it is shifted left by 8
bits, and the 8 least significant bits if the pointer are taken from
the data stream. The one's-complement of the result is taken. <br>

The length adjustment for -1280 and -32000 is saved and added back in
later (it's always at least one). Then it goes into the same LZ as
before, with the next two bits of the control stream being the length
unless they are both zero, etc.
</p>


<p>Example:
</p>


<p>64 6d 08 69 61
</p>

<p>64 = 01100100<br>
0 = next byte is literal 0x6d<br>
1 = compressed data<br>
10 = LZ with MSB of pointer zero after subtracting 3<br>
</p>

<p>08 -- byte from data stream, pointer to -9 bytes back (points to the 'a' in Danny)
</p>

<p>01 -- from control stream, a length of 1, plus the adjustment 1 from earlier = 2.<br>

0 -- indicates a literal 69<br>
0 -- indicates a literal 61. "
</p>

<p>For more details, look in the source code <a href="https://github.com/lclevy/unmo3/blob/master/mo3_unpack.c">here</a>.
</p>

<p>This algorithm is copyrighted Ian Luck, and is also used in <a href="http://www.un4seen.com/petite/">PEtite</a>.
</p>

<h3>2.3 The music data, after decompression</h3>

<h4>2.3.1 General data</h4>

<table border="1" cellpadding="2">
  <tbody>
    <tr>
      <td> Address </td>
      <td> Length </td>
      <td> Type </td>
      <td> Description</td>
    </tr>
    <tr>
      <td> 0x0000 </td>
      <td> variable </td>
      <td> char[] </td>
      <td> song name (terminated by 00)</td>
    </tr>
    <tr>
      <td> computed </td>
      <td> variable </td>
      <td> char[] </td>
      <td> message (in IT, terminated by 00) </td>
    </tr>
  </tbody>
</table>


<p>
then, 0x1a6 bytes :
</p>

<table border="1" cellpadding="2">
  <tbody>
    <tr>
      <td> 0x0000 </td>
      <td> 1 </td>
      <td> byte </td>
      <td> number of channel, 0...64 (for example 04 for .mod, 0x20 for .xm) </td>
    </tr>
    <tr>
      <td> 0x0001 </td>
      <td> 1 </td>
      <td> short </td>
      <td> length of the order list (songlen) </td>
    </tr>
    <tr>
      <td> 0x0003 </td>
      <td> 1 </td>
      <td> short </td>
      <td> restart position (playback resumes at this position in the order list when it reaches the song end)</td>
    </tr>
    <tr>
      <td> 0x0005 </td>
      <td> 1 </td>
      <td> short </td>
      <td> number of patterns </td>
    </tr>
    <tr>
      <td> 0x0007 </td>
      <td> 1 </td>
      <td> short </td>
      <td> number of unique voices </td>
    </tr>
    <tr>
      <td> 0x0009 </td>
      <td> 1 </td>
      <td> short </td>
      <td> number of instruments </td>
    </tr>
    <tr>
      <td> 0x000b </td>
      <td> 1 </td>
      <td> short </td>
      <td> number of samples </td>
    </tr>
    <tr>
      <td> 0x000d </td>
      <td> 1 </td>
      <td> byte </td>
      <td> initial ticks/row </td>
    </tr>
    <tr>
      <td> 0x000e </td>
      <td> 1 </td>
      <td> byte </td>
      <td> initial tempo (default = 125) </td>
    </tr>
    <tr>
      <td> 0x000f </td>
      <td> 1 </td>
      <td> long </td>
      <td> flags<br>
      
      <ul>
        <li>Bit 0 (0x01): Linear frequency slides (IT, XM)</li>
		<li>Bit 1 (0x02): Is an S3M file</li> 
		<li>Bit 2 (0x04): S3M "Fast Volume Slides" (S3M)</li>
		<li>Bit 3 (0x08): Not an XM file</li>
		<li>Bit 4 (0x10): S3M "Amiga Limits" (S3M)</li>
		<li>Bit 5 (0x20): Can be found in some old files, but can be safely ignored (BASS/XMPlay/UNMO3 ignore it too)</li>
		<li>Bit 6 (0x40): Same as 0x20.</li>
		<li>Bit 7 (0x80): Is a MOD file</li>
		<li>Bit 8 (0x100): Is an IT file</li>
		<li>Bit 9 (0x200): Instrument Mode (IT)</li>
		<li>Bit 10 (0x400): IT Compatible Gxx (IT) - enabled if bit is <em>not</em> set</li>
		<li>Bit 11 (0x800): IT Old Effects (IT) - enabled if bit is <em>not</em> set</li>
		<li>Bit 16 (0x10000): MPT-compatible playback</li>
		<li>Bit 17 (0x20000): Always set</li>
		<li>Bit 19 (0x80000): MOD file uses VBlank timing (Fxx only sets speed, never tempo)</li>
		<li>Bit 20 (0x100000): Plugin chunk is present (after sample headers)</li>
		<li>Bit 21 (0x200000): Extended Filter Range (IT, XM)</li> 
      </ul>
      
      Bit 3 is set for all types except XM. MTM only has this type flag set, so the practical order for format checking is:
      <pre>
if (mo3Hdr-&gt;flags &amp; 0x0100)
    printf("IT");
else if (mo3Hdr-&gt;flags &amp; 0x0002)
    printf("S3M");
else if (mo3Hdr-&gt;flags &amp; 0x0080)
    printf("MOD");
else if (mo3Hdr-&gt;flags &amp; 0x0008)
    printf("MTM");
else
    printf("XM");</pre>
      </td>
    </tr>
    <tr>
      <td> 0x0013 </td>
      <td> 1 </td>
      <td> byte </td>
      <td> Global Volume (0...128 in IT, 0...64 in S3M, otherwise ignored)</td>
    </tr>
    <tr>
      <td> 0x0014 </td>
      <td> 1 </td>
      <td> byte </td>
      <td> Pan Separation (like in IT format - ignored in other formats)</td>
    </tr>
    <tr>
      <td> 0x0015 </td>
      <td> 1 </td>
      <td> byte </td>
      <td> Sample mix volume. To translate into Impulse Tracker's mix volume:
      	<pre>
if (mo3Hdr-&gt;mixvol&lt;0)
    it.mixvol=mo3Hdr-&gt;mixvol+52;
else
    it.mixvol=exp(mo3Hdr-&gt;mixvol*3.1/20.0)+51;</pre>
     </td>
    </tr>
    <tr>
      <td> 0x0016 </td>
      <td> 64 </td>
      <td> byte[] </td>
      <td> Default channel volumes (0...64, for 64 channels, only IT!). </td>
    </tr>
    <tr>
      <td> 0x0056 </td>
      <td> 64 </td>
      <td> byte[] </td>
      <td> Default channel panning (0...255, 127=surround, for 64 channels. ignore in XM!). </td>
    </tr>
    <tr>
      <td> 0x0096 </td>
      <td> 16 </td>
      <td> byte[] </td>
      <td> IT MIDI macros : SF0-SFF settings (equate to
"F0F0&lt;value-1&gt;z" in IT) </td>
    </tr>
    <tr>
      <td> 0x00a6 </td>
      <td> 128*2 </td>
      <td> byte </td>
      <td> IT MIDI macros : Z80-ZFF settings (2 bytes each,
equate to "F0F0&lt;value1&gt;&lt;value2&gt;") </td>
    </tr>
  </tbody>
</table>

<p>
Note: If all MIDI macros are 0, the default macro configuration (SF0 = Set Cutoff, Z80-Z8F = Set Resonance) is assumed.
</p>


<p>then :
</p>


<h4>2.3.2 Song and pattern data</h4>


<table border="1" cellpadding="2">
  <tbody>
    <tr>
      <td> Address </td>
      <td> Length </td>
      <td> Type </td>
      <td> Description </td>
    </tr>
    <tr>
      <td> 0x0000 </td>
      <td> songlen (see header above)</td>
      <td> byte[] </td>
      <td> song sequence / order list (pattern #) </td>
    </tr>
    <tr>
      <td> computed </td>
      <td> nb pattern * nb channel </td>
      <td> short[] </td>
      <td> for each pattern and each channel, this list contains the number of
      the unique voice that is being used. identical voices are detected and
      factorized at compression so that several pattern channels can refer to
      the same voice. </td>
    </tr>
    <tr>
      <td> computed </td>
      <td> nb pattern </td>
      <td> short[] </td>
      <td> pattern length table: number of rows for each pattern </td>
    </tr>
  
  </tbody>
</table>


<p>
In .mod each pattern has 64 row, and 4 channels (for ProTracker). Each
row is coded using 4 bytes. So a voice takes 4*64 bytes,
and a pattern 4*64*4 bytes.<br>
</p>

<p>
In MO3, the number of rows per pattern is variable (like in XM) and
stored in 'pattern length table'. To rebuild a pattern you have to use
the voice seq table. The voice data are stored as described above :
</p>


<p>For each voice data, repeated "nb unique voice" times.
</p>


<table border="1" cellpadding="2">
  <tbody>
    <tr>
      <td> Address </td>
      <td> Length </td>
      <td> Type </td>
      <td> Description </td>
    </tr>
    
    <tr>
      <td> 0x0000 </td>
      <td> 1 </td>
      <td> long </td>
      <td> length of this voice in bytes </td>

    </tr>

    <tr>
      <td> 0x0004 </td>
      <td> length </td>
      <td> byte[] </td>
      <td> voice data encoded as type/value list, see below<br>
    </td>

    </tr>
  
  </tbody>
</table>


<h5> Pattern encoding </h5> 

<p> Pattern data is encoded using control bytes and a type/value list for every
row. The control byte encodes both the length of the type/value
list (using the 4 rightmost bits) and if this row is repeated or not
(using the 4 leftmost bits). Every voice is terminated by a control byte value
of 0. A decoder should probably not (only) rely on this and also check the
length field, though. </p>

<p>
For example 0x30 means "3 times an empty row", and 0x32 means "this row
list has 2 type/value, and is repeated 3 times".
</p>


<table border="1" cellpadding="2">
  <tbody>
    <tr>
      <td> type (hex) </td>
      <td> type description</td>
      <td> value </td>
      <td> Description </td>
    </tr>
    <tr>
      <td> 01 </td>
      <td> note </td>
      <td> note number</td>
      <td> 0=C-0, 1=C#0, 2=D-0, 3=D#0, 4=E-0, ..., 0x58=E-6,
0x59=F-7, 0x5a=F#7, 0x5b=G-7. <br>
0xff means note off (==), 0xfe means note cut (^^), any other values above 120
are IT note fade (~~) </td>
    </tr>
    <tr>
      <td> 02 </td>
      <td> instrument </td>
      <td> intrument number-1</td>
      <td> the intrument 1 is coded "0". </td>
    </tr>
  </tbody>
</table>


<h5>Effects</h5>

<p>Every module effect command has its own "type", and the value byte is the
command's parameter.</p>

<ul>
<li><strong>Notation:</strong> Lowercase letters designate volume column
effects, uppercase letters go into the effect column.</br>
Effect notation is presented as in OpenMPT, so they may differ from e.g. how
they are displayed in FT2.</li>
<li><strong>Playback:</strong> Note that some commands appear multiple times in the table, presumably
because the BASS library has different playback handlers for each of the formats
in this case. All effects can be interpreted exactly as their counterparts in
the supported formats.<br/>
For example, if you encounter command 3 (arpeggio) in an MO3-ed IT file, play it
like Impulse Tracker would, if you encounter it in an MO3-ed XM file, play it
like FastTracker would.</li>
<li><strong>Conversion:</strong> For converting the MO3 file back into its
original format, all of this does not matter: You can simply convert the type
value and write out the value byte as-is.</li>
</ul>

<table border="1" cellpadding="2">
  <tbody>
    <tr>
      <td> type (hex)</td>
      <td> IT </td>
      <td> S3M </td>
      <td> XM </td>
      <td> MOD/MTM </td>
      <td> Description </td>
    </tr>

    <tr>
      <td> 03 </td>
      <td> J </td>
      <td> J </td>
      <td> 0 </td>
      <td> 0 </td>
      <td>Arpeggio </td>
    </tr>
    <tr>
      <td> 04 </td>
      <td> - </td>
      <td> - </td>
      <td> 1 </td>
      <td> 1 </td>
      <td>Portamento Up (for formats that have separate fine portamento commands) </td>
    </tr>
    <tr>
      <td> 05 </td>
      <td> - </td>
      <td> - </td>
      <td> 2 </td>
      <td> 2 </td>
      <td>Portamento Down (for formats that have separate fine portamento commands) </td>
    </tr>
    <tr>
      <td> 06 </td>
      <td> G, g </td>
      <td> G </td>
      <td> 3, g </td>
      <td> 3 </td>
      <td>Tone Portamento</td>
    </tr>
    <tr>
      <td> 07 </td>
      <td> H, h </td>
      <td> H </td>
      <td> 4 </td>
      <td> 4 </td>
      <td>Vibrato (volume column: vibrato depth, values 0...9 only)</td>
    </tr>
    <tr>
      <td> 08 </td>
      <td> - </td>
      <td> - </td>
      <td> 5 </td>
      <td> 5 </td>
      <td>Volume Slide + Tone Portamento. Note: The equivalent IT/S3M command (Lxx) is stored as two commands 07 00 22 xx instead. </td>
    </tr>
    <tr>
      <td> 09 </td>
      <td> - </td>
      <td> - </td>
      <td> 6 </td>
      <td> 6 </td>
      <td>Volume Slide + Vibrato. Note: The equivalent IT/S3M command (Kxx) is stored as two commands 06 00 22 xx instead. </td>
    </tr>
    <tr>
      <td> 0A </td>
      <td> R </td>
      <td> R </td>
      <td> 7 </td>
      <td> 7 </td>
      <td>Tremolo</td>
    </tr>
    <tr>
      <td> 0B </td>
      <td> X, p </td>
      <td> X </td>
      <td> 8, p </td>
      <td> 8 </td>
      <td>Panning</td>
    </tr>
    <tr>
      <td> 0C </td>
      <td> O </td>
      <td> O </td>
      <td> 9 </td>
      <td> 9 </td>
      <td>Sample Offset</td>
    </tr>
    <tr>
      <td> 0D </td>
      <td> - </td>
      <td> - </td>
      <td> A </td>
      <td> A </td>
      <td>Volume Slide</td>
    </tr>
    <tr>
      <td> 0E </td>
      <td> B </td>
      <td> B </td>
      <td> B </td>
      <td> B </td>
      <td>Position Jump</td>
    </tr>
    <tr>
      <td> 0F </td>
      <td> v </td>
      <td> v </td>
      <td> C, v </td>
      <td> C </td>
      <td>Set Volume</td>
    </tr>
    <tr>
      <td> 10 </td>
      <td> C </td>
      <td> C </td>
      <td> D </td>
      <td> D </td>
      <td>Break To Row. Note that this is BCD-encoded in MOD/XM/S3M/MTM, just like it is stored in such files! In IT files, the row is stored as a normal integer.</td>
    </tr>
    <tr>
      <td> 11 </td>
      <td> - </td>
      <td> - </td>
      <td> E </td>
      <td> E </td>
      <td>MOD Multi-Purpose Command (Exy)</td>
    </tr>
    <tr>
      <td> 12 </td>
      <td> - </td>
      <td> - </td>
      <td> F </td>
      <td> F </td>
      <td>Combined Set Speed (value &lt; 20) / Set Tempo (value &ge; 20) - if the VBlank flag is set in the header, all values are interpreted as Set Speed.</td>
    </tr>
    <tr>
      <td> 13 </td>
      <td> - </td>
      <td> - </td>
      <td> T </td>
      <td> - </td>
      <td>Tremor</td>
    </tr>
    <tr>
      <td> 14 </td>
      <td> - </td>
      <td> - </td>
      <td> c, d </td>
      <td> - </td>
      <td>Volume column volume slide up (if high nibble is set) or slide down (if low nibble is set)</td>
    </tr>
    <tr>
      <td> 15 </td>
      <td> - </td>
      <td> - </td>
      <td> a, b </td>
      <td> - </td>
      <td>Volume column fine volume slide up (if high nibble is set) or fine slide down (if low nibble is set)</td>
    </tr>
    <tr>
      <td> 16 </td>
      <td> V </td>
      <td> V </td>
      <td> G </td>
      <td> - </td>
      <td>Set Global Volume (param range 0...128 in IT, 0...64 in S3M / XM)</td>
    </tr>
    <tr>
      <td> 17 </td>
      <td> - </td>
      <td> - </td>
      <td> H </td>
      <td> - </td>
      <td>Global Volume Slide</td>
    </tr>
    <tr>
      <td> 18 </td>
      <td> - </td>
      <td> - </td>
      <td> K </td>
      <td> - </td>
      <td>Key Off</td>
    </tr>
    <tr>
      <td> 19 </td>
      <td> - </td>
      <td> - </td>
      <td> L </td>
      <td> - </td>
      <td>Set Envelope Position</td>
    </tr>
    <tr>
      <td> 1A </td>
      <td> - </td>
      <td> - </td>
      <td> P </td>
      <td> - </td>
      <td>Panning Slide</td>
    </tr>
    <tr>
      <td> 1B </td>
      <td> - </td>
      <td> - </td>
      <td> l, r </td>
      <td> - </td>
      <td>Volume column panning slide right (if high nibble is set) or left (if low nibble is set)</td>
    </tr>
    <tr>
      <td> 1C </td>
      <td> - </td>
      <td> - </td>
      <td> R </td>
      <td> - </td>
      <td>Retrigger Note</td>
    </tr>
    <tr>
      <td> 1D </td>
      <td> - </td>
      <td> - </td>
      <td> X1 </td>
      <td> - </td>
      <td>Extra fine portamento up</td>
    </tr>
    <tr>
      <td> 1E </td>
      <td> - </td>
      <td> - </td>
      <td> X2 </td>
      <td> - </td>
      <td>Extra fine portamento down</td>
    </tr>
    <tr>
      <td> 1F </td>
      <td> - </td>
      <td> - </td>
      <td> u </td>
      <td> - </td>
      <td>Volume column vibrato speed</td>
    </tr>
    <tr>
      <td> 20 </td>
      <td> - </td>
      <td> - </td>
      <td> h </td>
      <td> - </td>
      <td>Volume column vibrato depth</td>
    </tr>
    <tr>
      <td> 21 </td>
      <td> A </td>
      <td> A </td>
      <td> - </td>
      <td> - </td>
      <td>Set Speed</td>
    </tr>
    <tr>
      <td> 22 </td>
      <td> D </td>
      <td> D </td>
      <td> - </td>
      <td> - </td>
      <td>Volume Slide</td>
    </tr>
    <tr>
      <td> 23 </td>
      <td> E </td>
      <td> E </td>
      <td> - </td>
      <td> - </td>
      <td>Portamento Down (for formats without separate fine slides)</td>
    </tr>
    <tr>
      <td> 24 </td>
      <td> F </td>
      <td> F </td>
      <td> - </td>
      <td> - </td>
      <td>Portamento Up (for formats without separate fine slides)</td>
    </tr>
    <tr>
      <td> 25 </td>
      <td> I </td>
      <td> I </td>
      <td> - </td>
      <td> - </td>
      <td>Tremor</td>
    </tr>
    <tr>
      <td> 26 </td>
      <td> Q </td>
      <td> Q </td>
      <td> - </td>
      <td> - </td>
      <td>Retrigger Note</td>
    </tr>
    <tr>
      <td> 27 </td>
      <td> U </td>
      <td> U </td>
      <td> - </td>
      <td> - </td>
      <td>Fine Vibrato</td>
    </tr>
    <tr>
      <td> 28 </td>
      <td> M </td>
      <td> M </td>
      <td> - </td>
      <td> - </td>
      <td>Set Channel Volume</td>
    </tr>
    <tr>
      <td> 29 </td>
      <td> N </td>
      <td> N </td>
      <td> - </td>
      <td> - </td>
      <td>Channel Volume Slide</td>
    </tr>
    <tr>
      <td> 2A </td>
      <td> P </td>
      <td> P </td>
      <td> - </td>
      <td> - </td>
      <td>Panning Slide</td>
    </tr>
    <tr>
      <td> 2B </td>
      <td> S </td>
      <td> S </td>
      <td> - </td>
      <td> - </td>
      <td>S3M Multi-Purpose Command (Sxy)</td>
    </tr>
    <tr>
      <td> 2C </td>
      <td> T </td>
      <td> T </td>
      <td> - </td>
      <td> - </td>
      <td>Set Tempo</td>
    </tr>
    <tr>
      <td> 2D </td>
      <td> W </td>
      <td> W </td>
      <td> - </td>
      <td> - </td>
      <td>Global Volume Slide</td>
    </tr>
    <tr>
      <td> 2E </td>
      <td> Y </td>
      <td> Y </td>
      <td> Y </td>
      <td> - </td>
      <td>Panbrello</td>
    </tr>
    <tr>
      <td> 2F </td>
      <td> Z </td>
      <td> Z </td>
      <td> Z </td>
      <td> - </td>
      <td>MIDI Macro</td>
    </tr>
    <tr>
      <td> 30 </td>
      <td> a, b, c, d </td>
      <td> - </td>
      <td> - </td>
      <td> - </td>
      <td>Volume column combined volume slide command (values 0...9 = fine volume up, 10...19 = fine volume down, 20...29 = volume up, 30...39 = volume down) </td>
    </tr>
    <tr>
      <td> 31 </td>
      <td> e </td>
      <td> - </td>
      <td> - </td>
      <td> - </td>
      <td>Volume column portamento down</td>
    </tr>
    <tr>
      <td> 32 </td>
      <td> f </td>
      <td> - </td>
      <td> - </td>
      <td> - </td>
      <td>Volume column portamento up</td>
    </tr>
 
  </tbody>
</table>


One good example for MOD (almost all effects in a great music) is <a href="http://modarchive.org/module.php?36042">Danny
Elfmania</a> by <a href="http://www.elmobo.com">Moby</a><br>

<br>
Example (in hexa): 13 01 38 02 0d 0f 20<br>
<p>
13 : 1 row of 3 type/value<br>
01 38 : note is G#5<br>
02 0d : instrument is 14<br>
0f 20 : effect : C20
</p>

<p>Data for one voice is terminated with 00</p>

<h4>2.3.3 Instruments data</h4>


Instrument data takes 0x33a bytes, after the instrument name + filename (0
terminated)

<h5>Envelope Layout</h5>
Every instrument contains three envelopes, which follow this structure:
<table border="1" cellpadding="2">
  <tbody>
    <tr>
      <td> Address </td>
      <td> Length </td>
      <td> Type </td>
      <td> Description </td>
    </tr>
    
    <tr>
      <td> 0x0000 </td>
      <td> 1 </td>
      <td> byte </td>
      <td> Flags:
        <ul>
            <li>Bit 0 (0x01): Envelope enabled (IT, XM)</li>
            <li>Bit 1 (0x02): Sustain loop enabled (IT, XM)</li>
            <li>Bit 2 (0x04): Loop enabled (IT, XM)</li>
            <li>Bit 4 (0x10): Treat as filter envelope (only in the combined pitch/filter envelope, IT)</li>
            <li>Bit 5 (0x20): Envelope carry (IT)</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td> 0x0001 </td>
      <td> 1 </td>
      <td> byte </td>
      <td> Number of nodes </td>
    </tr>
    <tr>
      <td> 0x0002 </td>
      <td> 1 </td>
      <td> byte </td>
      <td> Sustain loop beginning </td>
    </tr>
    <tr>
      <td> 0x0003 </td>
      <td> 1 </td>
      <td> byte </td>
      <td> Sustain loop end </td>
    </tr>
    <tr>
      <td> 0x0004 </td>
      <td> 1 </td>
      <td> byte </td>
      <td> Loop beginning </td>
    </tr>
    <tr>
      <td> 0x0005 </td>
      <td> 1 </td>
      <td> byte </td>
      <td> Loop end </td>
    </tr>
    <tr>
      <td> 0x0006 </td>
      <td> 25*2 </td>
      <td> short </td>
      <td> Envelope data, 25 nodes : position (short), value
0-&gt;64 (short) or 0-&gt;2048 (in case of the combined pitch / filter envelope)</td>
    </tr>
  </tbody>
</table>




<table border="1" cellpadding="2">
  <tbody>
    <tr>
      <td> Address </td>
      <td> Length </td>
      <td> Type </td>
      <td> Description </td>
    </tr>
    <tr>
      <td> </td>
      <td> ? </td>
      <td> char[] </td>
      <td> instrument name (0 terminated) </td>
    </tr>
    <tr>
      <td> </td>
      <td> ? </td>
      <td> char[] </td>
      <td> instrument filename (0 terminated) - Only if version &ge; 5, otherwise not included </td>
    </tr>
    <tr>
      <td> 0x0000 </td>
      <td> 1 </td>
      <td> long </td>
      <td>flags :&nbsp;1 = play on MIDI, 2 = mute. These are
hardly ever used </td>
    </tr>
    <tr>
      <td> 0x0004 </td>
      <td> 10*12*2 </td>
      <td> short </td>
      <td> sample map : 10 octaves * 12 notes * 4 bytes<br>IT: first short = note [ignore in XM!],
second short = sample number). In XM, the first 96 values of the sample map are used, the remaining 24 are ignored.</td>
    </tr>
    <tr>
      <td> 0x01e4 </td>
      <td> 106 </td>
      <td> Envelope </td>
      <td> Volume Envelope </td>
    </tr>
    <tr>
      <td> 0x024e </td>
      <td> 106 </td>
      <td> Envelope </td>
      <td> Panning Envelope </td>
    </tr>
    <tr>
      <td> 0x02b8 </td>
      <td> 106 </td>
      <td> Envelope </td>
      <td> Combined Pitch / Filter Envelope </td>
    </tr>
    <tr>
      <td> 0x0322 </td>
      <td> 1 </td>
      <td> byte </td>
      <td> Vibrato Type (0=sine, 1=Ramp down, 2=square, 3=random) (XM only)
      </td>
    </tr>
    <tr>
      <td> 0x0323 </td>
      <td> 1 </td>
      <td> byte </td>
      <td> Vibrato Sweep (XM only) </td>
    </tr>
    <tr>
      <td> 0x0324 </td>
      <td> 1 </td>
      <td> byte </td>
      <td> Vibrato Depth (XM only) </td>
    </tr>
    <tr>
      <td> 0x0325 </td>
      <td> 1 </td>
      <td> byte </td>
      <td> Vibrato Rate (XM only) </td>
    </tr>
    <tr>
      <td> 0x0326 </td>
      <td> 1 </td>
      <td> short </td>
      <td> Fade Out </td>
    </tr>
    <tr>
      <td> 0x0328 </td>
      <td> 1 </td>
      <td> byte </td>
      <td> MIDI Channel </td>
    </tr>
    <tr>
      <td> 0x0329 </td>
      <td> 1 </td>
      <td> byte </td>
      <td> MIDI Bank </td>
    </tr>
    <tr>
      <td> 0x032a </td>
      <td> 1 </td>
      <td> byte </td>
      <td> MIDI Patch </td>
    </tr>
    <tr>
      <td> 0x032b </td>
      <td> 1 </td>
      <td> byte </td>
      <td> MIDI Bend </td>
    </tr>
    <tr>
      <td> 0x032c </td>
      <td> 1 </td>
      <td> byte </td>
      <td> Global Volume (0...128, IT only) </td>
    </tr>
    <tr>
      <td> 0x032d </td>
      <td> 1 </td>
      <td> short </td>
      <td> Panning (0...256 if enabled, 0xFFFF otherwise) </td>
    </tr>
    <tr>
      <td> 0x032f </td>
      <td> 1 </td>
      <td> byte </td>
      <td> New Note Action [IT] </td>
    </tr>
    <tr>
      <td> 0x0330 </td>
      <td> 1 </td>
      <td> byte </td>
      <td> Pitch Pan Separation [IT] </td>
    </tr>
    <tr>
      <td> 0x0331 </td>
      <td> 1 </td>
      <td> byte </td>
      <td> Pitch Pan Center [IT] </td>
    </tr>
    <tr>
      <td> 0x0332 </td>
      <td> 1 </td>
      <td> byte </td>
      <td> Duplicate Check Type [IT] </td>
    </tr>
    <tr>
      <td> 0x0333 </td>
      <td> 1 </td>
      <td> byte </td>
      <td> Duplicate Check Action [IT] </td>
    </tr>
    <tr>
      <td> 0x0334 </td>
      <td> 1 </td>
      <td> short </td>
      <td> Volume Swing (0...100) [IT] </td>
    </tr>
    <tr>
      <td> 0x0336 </td>
      <td> 1 </td>
      <td> short </td>
      <td> Pan Swing (0...256) [IT] </td>
    </tr>
    <tr>
      <td> 0x0338 </td>
      <td> 1 </td>
      <td> byte </td>
      <td> Initial Filter Cutoff (0...127, +128 if enabled) [IT] </td>
    </tr>
    <tr>
      <td> 0x0339 </td>
      <td> 1 </td>
      <td> byte </td>
      <td> Initial Filter Resonance (0...127, +128 if enabled) [IT] </td>
    </tr>
  
  </tbody>
</table>

<p>The number of sample for given instrument is deducted from the sample map.
</p>


<h4>2.3.4 Samples data</h4>

Samples data takes 0x29 bytes after the sample name (0x2B if some flags are set, see below), which is 0
terminated.
<table border="1" cellpadding="2">
  <tbody>
    <tr>
      <td> Address </td>
      <td> Length </td>
      <td> Type </td>
      <td> Description </td>
    </tr>
    <tr>
      <td> </td>
      <td> ? </td>
      <td> char[] </td>
      <td> Sample Name (0 terminated)<br>

       </td>
    </tr>
    <tr>
      <td> </td>
      <td> ? </td>
      <td> char[] </td>
      <td> Sample Filename (0 terminated) - Only if version &ge; 5, otherwise not included 
    </tr>
    <tr>
      <td> 0x0000 </td>
      <td> 1 </td>
      <td> long </td>
      <td> Finetune (0x00 in file = -128, 0x80 = 0, 0x76 = -10, 0x90 = 16) [MOD, MTM, XM]<br>
        or "C4/5 speed" (sample rate) for S3M and IT. Sample rate is in Hertz if version &ge; 5 or linear slides are disabled, otherwise it can be computed as follows: sampleRate = 8363.0 * pow(2.0, (Finetune + 1408) / 1536.0)</td>
    </tr>
    <tr>
      <td> 0x0004 </td>
      <td> 1 </td>
      <td> byte </td>
      <td> Transpose (-128... 127)</td>
    </tr>
    <tr>
      <td> 0x0005 </td>
      <td> 1 </td>
      <td> byte </td>
      <td> Default Volume (0...64) </td>
    </tr>
    <tr>
      <td> 0x0006 </td>
      <td> 1 </td>
      <td> short </td>
      <td> Panning (0...256 if enabled, 0xFFFF otherwise) </td>
    </tr>
    <tr>
      <td> 0x0008 </td>
      <td> 1 </td>
      <td> long </td>
      <td> Sample length in sampling points<br>
if size==0 and end!=0 : means removed sample (not used) </td>
    </tr>
    <tr>
      <td> 0x000c </td>
      <td> 1 </td>
      <td> long </td>
      <td> Loop Start </td>
    </tr>
    <tr>
      <td> 0x0010 </td>
      <td> 1 </td>
      <td> long </td>
      <td> Loop End </td>
    </tr>
    <tr>
      <td> 0x0014 </td>
      <td> 1 </td>
      <td> short </td>
      <td> Flags<br>
        <ul>
          <li>Bit 0 (0x01): 16-bit sample (8-bit otherwise)</li>
          <li>Bit 4 (0x10): Sample loop enabled</li>
          <li>Bit 5 (0x20): Ping-pong loop (set together with 0x10)</li>
          <li>Bit 8 (0x100): Sustain loop enabled</li>
          <li>Bit 9 (0x200): Ping-pong sustain loop (set together with 0x100)</li>
          <li>Bit 10 (0x400): Stereo sample</li>
          <li>Bit 12 (0x1000): 1=lossy compression (1=MP3 0x1000, together with bit#13 (0x3000) means OGG, together with bit#13/14 (0x7000) means OGG with shared Vorbis header)</li>
          <li>Bit 13 (0x2000): lossless compression 'delta' (with bit#12 cleared)</li>
          <li>Bit 14 (0x4000): lossless compression 'delta prediction'</li>
        </ul>
        If none of the compression flags (0x1000, 0x2000, 0x4000) are set, the sample is compressed at all, i.e. stored as normal signed integer PCM data.
      </td>
    </tr>
    <tr>
      <td> 0x0016 </td>
      <td> 1 </td>
      <td> byte </td>
      <td> Vibrato type (0=sine, 1=ramp down, 2=square, 3=random) [IT] </td>

    </tr>
    <tr>
      <td> 0x0017 </td>
      <td> 1 </td>
      <td> byte </td>
      <td> Vibrato Sweep [IT] </td>
    </tr>
    <tr>
      <td> 0x0018 </td>
      <td> 1 </td>
      <td> byte </td>
      <td> Vibrato Depth [IT] </td>
    </tr>
    <tr>
      <td> 0x0019 </td>
      <td> 1 </td>
      <td> byte </td>
      <td> Vibrato Rate [IT] </td>
    </tr>
    <tr>
      <td> 0x001a </td>
      <td> 1 </td>
      <td> byte </td>
      <td> Global Volume[IT] </td>
    </tr>
    <tr>
      <td> 0x001b </td>
      <td> 1 </td>
      <td> long </td>
      <td> Sustain Loop Start[IT] </td>
    </tr>
    <tr>
      <td> 0x001f </td>
      <td> 1 </td>
      <td> long </td>
      <td> Sustain Loop End [IT] </td>
    </tr>
    <tr>
      <td> 0x0023 </td>
      <td> 1 </td>
      <td> long </td>
      <td> Compressed Size. If it is negative, this is a copy of a previous sample (-1 is the previous sample, -2 the sample before that, etc.). </td>
    </tr>
    <tr>
      <td> 0x0027 </td>
      <td> 1 </td>
      <td> short </td>
      <td> MP3: Encoder Delay in bytes. This also includes the samples cut off by LAME's gapless header!<br>
           OGG: If shared headers are used, this is the header size.</td>
    </tr>
    <tr>
      <td> 0x0029 </td>
      <td> 1 </td>
      <td> short </td>
      <td> Starting from format version 5, OGG-encoded samples can share their headers to reduce size even further. This field is only present if version &ge; 5 and flag bits 12 and 14 (0x1000 | 0x4000) are set. In this case, the short indicates which sample the OGG header is taken from. </td>
    </tr>
  
  </tbody>
</table>


<h3>2.4 Plugins</h3>

If the plugin flag is set in the header, plugin data follows:

The first byte determines if plugin to channel mappings follow. If the byte is
1, read a long for every channel. If it is 0, no plugin is assinged to this
channel, if it is 1, the first plugin is assigned, etc.
Afterwards the plugin data follows.
A byte indicates for which plugin it is (0 = done, 1 = first plugin, etc.)
This data follows the OpenMPT plugin information as it can be found in IT, XM
and MPTM files (FX00, FX01, ... chunks).

<h3>3. Samples</h3>


The samples lossless algorithms are <a href="https://github.com/lclevy/unmo3">here</a>
(mo3_unpack.c).<br>


There is one version for 8 bits sample and another one for 16 bits
samples.<br>


There is 2 kind of algorithm : 1 based on delta encoding (as in <a href="xm.txt">xm</a>), a second one based on delta
prediction encoding. Then these delta values are stored in a compact
way.
<h3>4. Source code</h3>


The source code version 0.6 is available <a href="https://github.com/lclevy/unmo3">here</a>.
Here is an extract of the 'readme' file:
<p>"The piece of code has been written as a compagnion
(validation code) of the document "the unofficial MO3 specification".
</p>


<p>It is targeted towards developers or technical people, not for end
users. It can be used by IT/XM/S3M modules
specialists (tracker editor developer or modules players) to write a
MO3 import loader, or more generally to handle MO3 modules in any way.
</p>


<p>The MO3 format has been created by Ian Luck
(http://www.un4seen.com).
If you are looking for a good encoder and decoder (but without the
source code) and a good module player,
Ian's web site is the right place to go. </p>


<p>The features of unmo3 (opensource version) are:
</p>


<ul>


  <li> uncompress the MO3 header and samples with lossless
compressions. </li>
  <li> able to save to a file uncompressed header and samples </li>
  <li> able to extract mp3 and ogg compressed samples </li>
  <li> can display a channel of a given pattern into 2 forms
    <ul>
      <li> as encoded inside MO3 file </li>
      <li> as it usually appears in a tracker editor (for .mod only) </li>
    </ul>
  </li>

</ul>


<p>You can see output of the 'demo' <a href="demo.txt">here</a>
and the auto tests <a href="test.txt">here</a>.
For tests, a second archive '<a href="unmo3_test.zip">unmo3_test.zip</a>'
is required (has to be uncompressed in the same place as the 'unmo3_src.zip' archive).
</p>
The Win32 binary is here <a href="unmo3.exe">unmo3.exe</a>.

<h3>5. Other information</h3>


unmo3 Win32 executable is compressed with <a href="http://www.un4seen.com/petite/">PEtite</a>, and
Linux executable with <a href="http://upx.sourceforge.net/">UPX</a>.
<p>
Other modules file formats are available here (from <a href="http://www.wotsit.org">Wotsit</a>):
</p>


<ul>
  <li><a href="mod.txt">mod</a> </li>
  <li><a href="xm.txt">xm</a> <a href="xm_errata.txt">corrections</a> </li>
  <li><a href="mtm.txt">mtm</a> <a href="mtm-efx.txt">doc</a> </li>
  <li><a href="it.txt">it</a> </li>
  <li><a href="s3m.txt">s3m</a> </li>
</ul>


Previous work on Amiga module compression is available <a href="http://membres.lycos.fr/asle/ampd.html">here</a>
(Sylvain Chipaux and Gryzor).
<p>You can find on <a href="http://lclevy.free.fr/exotica">Exotica</a>
a huge collection of Amiga music formats descriptions.
</p>


<p>State of the art waveform compression is explained here : <a href="http://www.true-audio.com/codec.theory">TTA</a>,
<a href="http://citeseer.ist.psu.edu/robinson94shorten.html">Shorten</a>,
<a href="http://www.hpl.hp.com/techreports/1999/HPL-1999-144.pdf%20">AudioPak</a>,
and <a href="http://flac.sourceforge.net/">FLAC</a>.
</p>


<ul>
<li><a href="https://github.com/kode54/dumb/">DUMB</a>
is a free opensource library to replay XM, IT, MOD and S3M modules.</li>
<li><a href="https://github.com/cmatsuoka/libxmp/">XMP</a> is a portable and opensource module player.</li>
</ul>

<p>-end of the document-
</p>


</body>
</html>
