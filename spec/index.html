<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  
  <title>unofficial MO3 format description</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta content="MO3 format;mod format;module mp3;compressed module;file format;mo3 decompression;mo3 decoding" name="keywords" />
  <meta content="the unofficial MO3 format description, with source code (GPL)" name="description" />
  
  <style type="text/css">
.mo3 { color: rgb(255, 102, 0);
font-weight: normal;
font-style: normal;
text-transform: none;
text-align: left;
}
  </style>
</head>


<body>


<center>
<h1>The unofficial MO3 format description</h1>
<h3>open source MO3 decompression and decoding support (but not playback)</h3>
</center>


<hr/>News:
<ul>
  <li>2021-12-01 : OpenMPT MPTM Set Finetune and Set Finetune (Smooth) commands are now documented.</li>
  <li>2020-06-04 : AdLib / OPL instrument support, as added in MO3 2.4.1.5, is now documented.</li>
  <li>2020-05-13 : some more new features from MO3 2.4.1.2 are now documented.</li>
  <li>2016-01-26 : new v5 misc chunks and commands are now documented. This document is now considered to be complete.</li>
  <li>2015-11-16 : small clarifications and updates</li>
  <li>2015-11-10 : updated specification by Johannes Schultz, version 0.93.</li>
  <li>2014-05-21 : code and specification pushed to <a href="https://github.com/lclevy/unmo3">Github</a>, to ease third party contributions</li>
  <li>2009-07-19 : v2.4 MO3 encoder updates: code updated to v0.6, and specification updated to 0.91. </li>
  <li>2006-02-26 : unmo3 <b>source code</b> v0.5 is released (for technical people only). See section 4. and <a href="README.txt">Readme</a>. </li>
  <li>2006-02-15 : format descriptions updates (infos about IT MIDI macros and instruments envelopes from Ian Luck) </li>
  <li>2006-02-05 : the unpack algorithms source code (5 functions) is released. The unpack algorithms are explained. </li>
</ul>


<hr/>
<h3>Version 1.00<br/>
January 26th, 2016<br/>
<img src="em.png" />
</h3>


<h2>0. Credits</h2>

<ul>
  <li>Laurent Cl√©vy is the original author of this document.</li>
  <li>Laurent Laubin for the PEtite decompression</li>
  <li>Matthew T. Russotto for the unpack compression explanation</li>
  <li>Ian Luck for answering questions about missing parts of thespec: IT macros, IT instruments structure, modules flags, IT fields of samples, plus some others... </li>
  <li>Stuart for initial discussion about the unpack compression.</li>
  <li>Johannes Schultz for further information on the format (all updates since version 0.93 of this document).</li>
</ul>



<h2>1. Introduction</h2>


This description is applicable to mo3 encoder v1.8, v2.1, v2.2 and v2.4.
<h3>1.1 Overview</h3>


<p>The MO3 format means "MOdule with MP3", because the main initial idea
was to reduce the size of
a module (in MOD, XM, MTM, S3M, IT, MPTM format) by compressing the samples
using MPEG audio.
This format has been created by Ian Luck (<a href="https://www.un4seen.com/">https://www.un4seen.com/</a>).
</p>


<p>But not only the samples are compressed, but also the music
data, containing mainly notes, instruments number
and effects, as well as instruments information. <br/>


And a lot of effort has been used to reduce the size of this part. Then
a specific lossless compression is applied on music data.
</p>


<p>The samples can be compressed using Ogg, MP3, and 2 kind of
specific lossless algorithms.
</p>


<p>We can define "compression" a scheme which detects all kind
repetition in some data, then encodes these repetition in a more
compact way. This principle is very well applied in MO3 for music data
encoding.
</p>


<p>Note: MPTM files are technically extended IT files, so unless noted otherwise,
all IT-specific documentation below applies to MPTM files as well.</p>


<h3>1.2 The music data size reduction</h3>


The first idea of the MO3 encoder is to parse the music data and detect
unused samples, then they are removed from the module.
<p>When composing a module, musicians often cut and paste the
content of a channel (later called a "voice") from one pattern
to another one : for example drums, and bass. So this kind of
repetition is detected by the encoder : a list of unique voice is
built, then the patterns are encoded using pointers onto these unique
voice data. This idea is used in <a href="mtm.txt">mtm</a>
format.<br/>


This is very efficient especially for the "empty" voice : for example
in a module with 4 channels, often only 3 voices are used per pattern.
So the "empty" voice is repeated a lot of time.
</p>


<p>In a voice, one row can be repeated several times. This is
true for the empty row. This kind of repetition is detected and
stored in a compact way.
</p>


<p>The last size optimisation is how the row in a voice data is
encoded, using a list of type/value items.
</p>



<h3>1.3 The sample delta encodings</h3>


Digitized audio data are generally signed values stored in 8bits or
16bits. If directly compressed using general purpose
lossless compression algorithms, best result are about 10% of
reduction, which is poor.<br/>

Audio samples are very random signals, so with few
repetitions.<br/>

But the successive values are close to each other, so a good idea is
first encode them as delta values, (the first being 0 for example)
before compression. This is done in the 'delta' version of the MO3
lossless packers, and in XM modules.<br/>

But there is more smart as the mathematical slope of audio data is
often constant : encode the error for the next predicted delta, instead
of directly
the delta value. Then the 'prediction' is adjusted with the error : so
the prediction is converging to the right 'next' delta value.<br/>


This method is more efficient than simple delta one, especially on 16
bits data.


<h2>2. The file format</h2>


<h3>2.1 Compressed form</h3>


0x10 is the notation of an hexadecimal value (16 in decimal)<br/>
short (2 bytes) and long (4 bytes) are stored in file in little endian order (intel x86)

<table border="1" cellpadding="2">
  <tbody>
    <tr>
      <td> Address </td>
      <td> Length </td>
      <td> Type </td>
      <td> Description</td>
    </tr>
    <tr>
      <td> 0x0000 </td>
      <td> 3 </td>
      <td> char </td>
      <td> "MO3"</td>
    </tr>
    <tr>
      <td> 0x0003 </td>
      <td> 1 </td>
      <td> byte </td>
      <td> version (0 with MP3 and lossless, 4 with v2.1, 1 with
ogg) related with sample compression, 4 should means "with no LAME header".<br/> 3 means v2.2 and 5 v2.4 </td>

    </tr>
    <tr>
      <td> 0x0004 </td>
      <td> 1 </td>
      <td> long </td>
      <td> uncompressed length of header (music data) </td>
    </tr>
  </tbody>
</table>
Encoder version 2.2 and earlier (version == 0 ... 4):
<table border="1" cellpadding="2">
  <tbody>
    <tr>
      <td> 0x0008 </td>
      <td> computed </td>
      <td> byte[] </td>
      <td> compressed music data (see section 2.2 - 2.5) </td>
    </tr>
    <tr>
      <td> computed </td>
      <td> computed </td>
      <td> byte[] </td>
      <td> samples, compressed or not, using lossless, MP3 or Ogg
      </td>
    </tr>
  
  </tbody>
</table>
Encoder version 2.4 (version &ge; 5):
<table border="1" cellpadding="2">
  <tbody>
    <tr>
      <td> 0x0008 </td>
      <td> 1 </td>
      <td> long </td>
      <td> length of compressed data (sample data starts at this value + 12) </td>
    </tr>  
    <tr>
      <td> 0x000c </td>
      <td> computed </td>
      <td> byte[] </td>
      <td> compressed music data (see section 2.2 - 2.5) </td>
    </tr>
    <tr>
      <td> computed </td>
      <td> computed </td>
      <td> byte[] </td>
      <td> samples, compressed or not, using lossless, MP3 or Ogg
      </td>
    </tr>
  
  </tbody>
</table>

<h3>2.2 The music data decompression algorithm</h3>


Here is Matthew's explanation:
<p>"The first byte is always uncompressed. After that, you've got
two interleaved streams of control bytes and data bytes. The control
bytes are read by the shift_dl routine. <br/>

In the unpack routine, the control bits are read most-significant first. <br/>

A zero bit indicates "uncompressed byte". A one bit indicates compressed data. <br/>

The next two control bits control which kind of compression <br/>

-- if they are '00' it's LZ with the same (relative) pointer as a previous LZ. <br/>

The next two bits of the control stream are the length, unless they are both zero. </p>

<p>If they are both zero, the true length minus 2 is encoded in
the control stream, two bits per bit. <br/>

The first bit in each pair is the actual data, the second bit is 0 on
the last pair.
</p>

<p>If the first control bits are '11', '10' or '01', then the LZ
pointer is in the control stream. <br/>

The most significant bit of the pointer is a '1', then the next most
significant bits of the pointer are read from the control stream two
bits at a time as described above (including the initial 11 or 01 or
10). Then 3 is subtracted from that value and it is shifted left by 8
bits, and the 8 least significant bits if the pointer are taken from
the data stream. The one's-complement of the result is taken. <br/>

The length adjustment for -1280 and -32000 is saved and added back in
later (it's always at least one). Then it goes into the same LZ as
before, with the next two bits of the control stream being the length
unless they are both zero, etc.
</p>


<p>Example:
</p>


<p>64 6d 08 69 61
</p>

<p>64 = 01100100<br/>
0 = next byte is literal 0x6d<br/>
1 = compressed data<br/>
10 = LZ with MSB of pointer zero after subtracting 3<br/>
</p>

<p>08 -- byte from data stream, pointer to -9 bytes back (points to the 'a' in Danny)
</p>

<p>01 -- from control stream, a length of 1, plus the adjustment 1 from earlier = 2.<br/>

0 -- indicates a literal 69<br/>
0 -- indicates a literal 61. "
</p>

<p>For more details, look in the source code <a href="https://github.com/lclevy/unmo3/blob/master/mo3_unpack.c">here</a>.
</p>

<p>This algorithm is copyrighted Ian Luck, and is also used in <a href="https://www.un4seen.com/petite/">PEtite</a>.
</p>

<h3>2.3 The music data, after decompression</h3>

<h4>2.3.1 General data</h4>

<table border="1" cellpadding="2">
  <tbody>
    <tr>
      <td> Address </td>
      <td> Length </td>
      <td> Type </td>
      <td> Description</td>
    </tr>
    <tr>
      <td> 0x0000 </td>
      <td> variable </td>
      <td> char[] </td>
      <td> song name (terminated by 00)</td>
    </tr>
    <tr>
      <td> computed </td>
      <td> variable </td>
      <td> char[] </td>
      <td> message (in IT, terminated by 00) </td>
    </tr>
  </tbody>
</table>


<p>
then, 0x1a6 bytes :
</p>

<table border="1" cellpadding="2">
  <tbody>
    <tr>
      <td> 0x0000 </td>
      <td> 1 </td>
      <td> byte </td>
      <td> number of channel, 0...64 (for example 04 for .mod, 0x20 for .xm) </td>
    </tr>
    <tr>
      <td> 0x0001 </td>
      <td> 1 </td>
      <td> short </td>
      <td> length of the order list (songlen) </td>
    </tr>
    <tr>
      <td> 0x0003 </td>
      <td> 1 </td>
      <td> short </td>
      <td> restart position (playback resumes at this position in the order list when it reaches the song end)</td>
    </tr>
    <tr>
      <td> 0x0005 </td>
      <td> 1 </td>
      <td> short </td>
      <td> number of patterns </td>
    </tr>
    <tr>
      <td> 0x0007 </td>
      <td> 1 </td>
      <td> short </td>
      <td> number of unique voices </td>
    </tr>
    <tr>
      <td> 0x0009 </td>
      <td> 1 </td>
      <td> short </td>
      <td> number of instruments </td>
    </tr>
    <tr>
      <td> 0x000b </td>
      <td> 1 </td>
      <td> short </td>
      <td> number of samples </td>
    </tr>
    <tr>
      <td> 0x000d </td>
      <td> 1 </td>
      <td> byte </td>
      <td> initial ticks/row </td>
    </tr>
    <tr>
      <td> 0x000e </td>
      <td> 1 </td>
      <td> byte </td>
      <td> initial tempo (default = 125) </td>
    </tr>
    <tr>
      <td> 0x000f </td>
      <td> 1 </td>
      <td> long </td>
      <td> flags<br/>
      
      <ul>
        <li>Bit 0 (0x01): Linear frequency slides (IT, XM)</li>
		<li>Bit 1 (0x02): Is an S3M file</li> 
		<li>Bit 2 (0x04): S3M "Fast Volume Slides" (S3M)</li>
		<li>Bit 3 (0x08): Not an XM file</li>
		<li>Bit 4 (0x10): S3M "Amiga Limits" (S3M)</li>
		<li>Bit 5 (0x20): Can be found in some old files, but can be safely ignored (BASS/XMPlay/UNMO3 ignore it too)</li>
		<li>Bit 6 (0x40): Same as 0x20.</li>
		<li>Bit 7 (0x80): Is a MOD file</li>
		<li>Bit 8 (0x100): Is an IT or MPTM file</li>
		<li>Bit 9 (0x200): Instrument Mode (IT)</li>
		<li>Bit 10 (0x400): IT Compatible Gxx (IT) - enabled if bit is <em>not</em> set</li>
		<li>Bit 11 (0x800): IT Old Effects (IT) - enabled if bit is <em>not</em> set</li>
		<li>Bit 16 (0x10000): MPT-compatible playback (for BASS/XMPlay)</li>
		<li>Bit 17 (0x20000): Always set (internal BASS flag to designate modules)</li>
		<li>Bit 19 (0x80000): MOD file uses VBlank timing (Fxx only sets speed, never tempo)</li>
		<li>Bit 20 (0x100000): Plugin chunk is present (after sample headers)</li>
		<li>Bit 21 (0x200000): Extended Filter Range (IT, XM)</li> 
      </ul>
      
      Bit 3 is set for all types except XM. MTM only has this type flag set, so the practical order for format checking is:
      <pre>
if (mo3Hdr-&gt;flags &amp; 0x0100)
    printf("IT/MPTM");
else if (mo3Hdr-&gt;flags &amp; 0x0002)
    printf("S3M");
else if (mo3Hdr-&gt;flags &amp; 0x0080)
    printf("MOD");
else if (mo3Hdr-&gt;flags &amp; 0x0008)
    printf("MTM");
else
    printf("XM");</pre>
      </td>
    </tr>
    <tr>
      <td> 0x0013 </td>
      <td> 1 </td>
      <td> byte </td>
      <td> Global Volume (0...128 in IT, 0...64 in S3M, otherwise ignored)</td>
    </tr>
    <tr>
      <td> 0x0014 </td>
      <td> 1 </td>
      <td> byte </td>
      <td> Pan Separation (like in IT format - ignored in other formats)</td>
    </tr>
    <tr>
      <td> 0x0015 </td>
      <td> 1 </td>
      <td> byte </td>
      <td> Sample mix volume. To translate into Impulse Tracker's mix volume:
      	<pre>
if (mo3Hdr-&gt;mixvol&lt;0)
    it.mixvol=mo3Hdr-&gt;mixvol+52;
else
    it.mixvol=exp(mo3Hdr-&gt;mixvol*3.1/20.0)+51;</pre>
     </td>
    </tr>
    <tr>
      <td> 0x0016 </td>
      <td> 64 </td>
      <td> byte[] </td>
      <td> Default channel volumes (0...64, for 64 channels, only IT/MPTM!). </td>
    </tr>
    <tr>
      <td> 0x0056 </td>
      <td> 64 </td>
      <td> byte[] </td>
      <td> Default channel panning (0...255, 127=surround, for 64 channels. Ignore in XM!).<br/><strong>S3M Only</strong>: Starting from MO3 2.4.1.5, the second half of the table contains the 32 entries of the channel type table from the S3M header. This way, the original channel type (e.g. for AdLib instruments) can be reconstructed.</td>
    </tr>
    <tr>
      <td> 0x0096 </td>
      <td> 16 </td>
      <td> byte[] </td>
      <td> IT MIDI macros : SF0-SFF settings (equate to
"F0F0&lt;value-1&gt;z" in IT) </td>
    </tr>
    <tr>
      <td> 0x00a6 </td>
      <td> 128*2 </td>
      <td> byte </td>
      <td> IT MIDI macros : Z80-ZFF settings (2 bytes each,
equate to "F0F0&lt;value1&gt;&lt;value2&gt;") </td>
    </tr>
  </tbody>
</table>

<p>
Note: If all MIDI macros are 0, the default macro configuration (SF0 = Set Cutoff, Z80-Z8F = Set Resonance) is assumed.
</p>


<p>then :
</p>


<h4>2.3.2 Song and pattern data</h4>


<table border="1" cellpadding="2">
  <tbody>
    <tr>
      <td> Address </td>
      <td> Length </td>
      <td> Type </td>
      <td> Description </td>
    </tr>
    <tr>
      <td> 0x0000 </td>
      <td> songlen (see header above)</td>
      <td> byte[] </td>
      <td> song sequence / order list (pattern #) </td>
    </tr>
    <tr>
      <td> computed </td>
      <td> nb pattern * nb channel </td>
      <td> short[] </td>
      <td> for each pattern and each channel, this list contains the number of
      the unique voice that is being used. identical voices are detected and
      factorized at compression so that several pattern channels can refer to
      the same voice. </td>
    </tr>
    <tr>
      <td> computed </td>
      <td> nb pattern </td>
      <td> short[] </td>
      <td> pattern length table: number of rows for each pattern </td>
    </tr>
  
  </tbody>
</table>


<p>
In MO3, the number of rows per pattern is variable (like in IT/XM) and
stored in the 'pattern length table'. To rebuild a pattern you have to use
the voice seq table. The voice data are stored as described above :
</p>


<p>For each voice data, repeated "nb unique voice" times.
</p>


<table border="1" cellpadding="2">
  <tbody>
    <tr>
      <td> Address </td>
      <td> Length </td>
      <td> Type </td>
      <td> Description </td>
    </tr>
    
    <tr>
      <td> 0x0000 </td>
      <td> 1 </td>
      <td> long </td>
      <td> length of this voice in bytes </td>

    </tr>

    <tr>
      <td> 0x0004 </td>
      <td> length </td>
      <td> byte[] </td>
      <td> voice data encoded as type/value list, see below<br/>
    </td>

    </tr>
  
  </tbody>
</table>


<h5> Pattern encoding </h5> 

<p> Pattern data is encoded using control bytes and a type/value list for every
row. The control byte encodes both the length of the type/value
list (using the 4 rightmost bits) and if this row is repeated or not
(using the 4 leftmost bits). Every voice is terminated by a control byte value
of 0. A decoder should probably not (only) rely on this and also check the
length field, though. </p>

<p>
For example 0x30 means "3 times an empty row", and 0x32 means "this row
list has 2 type/value, and is repeated 3 times".
</p>


<table border="1" cellpadding="2">
  <tbody>
    <tr>
      <td> type (hex) </td>
      <td> type description</td>
      <td> value </td>
      <td> Description </td>
    </tr>
    <tr>
      <td> 01 </td>
      <td> note </td>
      <td> note number</td>
      <td> 0=C-0, 1=C#0, 2=D-0, 3=D#0, 4=E-0, ..., 0x58=E-6,
0x59=F-7, 0x5a=F#7, 0x5b=G-7. <br/>
0xff means note off (==), 0xfe means note cut (^^), any other values above 120
are IT note fade (~~) </td>
    </tr>
    <tr>
      <td> 02 </td>
      <td> instrument </td>
      <td> instrument number-1</td>
      <td> the instrument 1 is coded "0". </td>
    </tr>
  </tbody>
</table>


<h5>Effects</h5>

<p>Every module effect command has its own "type", and the value byte is the
command's parameter.</p>

<ul>
<li><strong>Notation:</strong> Lowercase letters designate volume column
effects, uppercase letters go into the effect column.<br/>
Effect notation is presented as in OpenMPT, so they may differ from e.g. how
they are displayed in FT2.</li>
<li><strong>Playback:</strong> Note that some commands appear multiple times in the table, presumably
because the BASS library has different playback handlers for each of the formats
in this case. All effects can be interpreted exactly as their counterparts in
the supported formats.<br/>
For example, if you encounter command 3 (arpeggio) in an MO3-ed IT file, play it
like Impulse Tracker would, if you encounter it in an MO3-ed XM file, play it
like FastTracker would.</li>
<li><strong>Conversion:</strong> For converting the MO3 file back into its
original format, all of this does not matter: You can simply convert the type
value and write out the value byte as-is.</li>
</ul>

<table border="1" cellpadding="2">
  <tbody>
    <tr>
      <td> type (hex)</td>
      <td> IT </td>
      <td> S3M </td>
      <td> XM </td>
      <td> MOD/MTM </td>
      <td> Description </td>
    </tr>

    <tr>
      <td> 03 </td>
      <td> J </td>
      <td> J </td>
      <td> 0 </td>
      <td> 0 </td>
      <td>Arpeggio </td>
    </tr>
    <tr>
      <td> 04 </td>
      <td> - </td>
      <td> - </td>
      <td> 1 </td>
      <td> 1 </td>
      <td>Portamento Up (for formats that have separate fine portamento commands) </td>
    </tr>
    <tr>
      <td> 05 </td>
      <td> - </td>
      <td> - </td>
      <td> 2 </td>
      <td> 2 </td>
      <td>Portamento Down (for formats that have separate fine portamento commands) </td>
    </tr>
    <tr>
      <td> 06 </td>
      <td> G, g </td>
      <td> G </td>
      <td> 3, g </td>
      <td> 3 </td>
      <td>Tone Portamento</td>
    </tr>
    <tr>
      <td> 07 </td>
      <td> H, h </td>
      <td> H </td>
      <td> 4 </td>
      <td> 4 </td>
      <td>Vibrato (volume column: vibrato depth, values 0...9 only)</td>
    </tr>
    <tr>
      <td> 08 </td>
      <td> - </td>
      <td> - </td>
      <td> 5 </td>
      <td> 5 </td>
      <td>Volume Slide + Tone Portamento. Note: The equivalent IT/S3M command (Lxx) is stored as two commands 07 00 22 xx instead. </td>
    </tr>
    <tr>
      <td> 09 </td>
      <td> - </td>
      <td> - </td>
      <td> 6 </td>
      <td> 6 </td>
      <td>Volume Slide + Vibrato. Note: The equivalent IT/S3M command (Kxx) is stored as two commands 06 00 22 xx instead. </td>
    </tr>
    <tr>
      <td> 0A </td>
      <td> R </td>
      <td> R </td>
      <td> 7 </td>
      <td> 7 </td>
      <td>Tremolo</td>
    </tr>
    <tr>
      <td> 0B </td>
      <td> X, p </td>
      <td> X </td>
      <td> 8, p </td>
      <td> 8 </td>
      <td>Panning</td>
    </tr>
    <tr>
      <td> 0C </td>
      <td> O </td>
      <td> O </td>
      <td> 9 </td>
      <td> 9 </td>
      <td>Sample Offset</td>
    </tr>
    <tr>
      <td> 0D </td>
      <td> - </td>
      <td> - </td>
      <td> A </td>
      <td> A </td>
      <td>Volume Slide</td>
    </tr>
    <tr>
      <td> 0E </td>
      <td> B </td>
      <td> B </td>
      <td> B </td>
      <td> B </td>
      <td>Position Jump</td>
    </tr>
    <tr>
      <td> 0F </td>
      <td> v </td>
      <td> v </td>
      <td> C, v </td>
      <td> C </td>
      <td>Set Volume</td>
    </tr>
    <tr>
      <td> 10 </td>
      <td> C </td>
      <td> C </td>
      <td> D </td>
      <td> D </td>
      <td>Break To Row. Note that this is BCD-encoded in MOD/XM/S3M/MTM, just like it is stored in such files! In IT files, the row is stored as a normal integer.</td>
    </tr>
    <tr>
      <td> 11 </td>
      <td> - </td>
      <td> - </td>
      <td> E </td>
      <td> E </td>
      <td>MOD Multi-Purpose Command (Exy)</td>
    </tr>
    <tr>
      <td> 12 </td>
      <td> - </td>
      <td> - </td>
      <td> F </td>
      <td> F </td>
      <td>Combined Set Speed (value &lt; 20) / Set Tempo (value &ge; 20) - if the VBlank flag is set in the header, all values are interpreted as Set Speed.</td>
    </tr>
    <tr>
      <td> 13 </td>
      <td> - </td>
      <td> - </td>
      <td> T </td>
      <td> - </td>
      <td>Tremor</td>
    </tr>
    <tr>
      <td> 14 </td>
      <td> - </td>
      <td> - </td>
      <td> c, d </td>
      <td> - </td>
      <td>Volume column volume slide up (if high nibble is set) or slide down (if low nibble is set)</td>
    </tr>
    <tr>
      <td> 15 </td>
      <td> - </td>
      <td> - </td>
      <td> a, b </td>
      <td> - </td>
      <td>Volume column fine volume slide up (if high nibble is set) or fine slide down (if low nibble is set)</td>
    </tr>
    <tr>
      <td> 16 </td>
      <td> V </td>
      <td> V </td>
      <td> G </td>
      <td> - </td>
      <td>Set Global Volume (param range 0...128 in IT, 0...64 in S3M / XM)</td>
    </tr>
    <tr>
      <td> 17 </td>
      <td> - </td>
      <td> - </td>
      <td> H </td>
      <td> - </td>
      <td>Global Volume Slide</td>
    </tr>
    <tr>
      <td> 18 </td>
      <td> - </td>
      <td> - </td>
      <td> K </td>
      <td> - </td>
      <td>Key Off</td>
    </tr>
    <tr>
      <td> 19 </td>
      <td> - </td>
      <td> - </td>
      <td> L </td>
      <td> - </td>
      <td>Set Envelope Position</td>
    </tr>
    <tr>
      <td> 1A </td>
      <td> - </td>
      <td> - </td>
      <td> P </td>
      <td> - </td>
      <td>Panning Slide</td>
    </tr>
    <tr>
      <td> 1B </td>
      <td> - </td>
      <td> - </td>
      <td> l, r </td>
      <td> - </td>
      <td>Volume column panning slide right (if high nibble is set) or left (if low nibble is set)</td>
    </tr>
    <tr>
      <td> 1C </td>
      <td> - </td>
      <td> - </td>
      <td> R </td>
      <td> - </td>
      <td>Retrigger Note</td>
    </tr>
    <tr>
      <td> 1D </td>
      <td> - </td>
      <td> - </td>
      <td> X1 </td>
      <td> - </td>
      <td>Extra fine portamento up</td>
    </tr>
    <tr>
      <td> 1E </td>
      <td> - </td>
      <td> - </td>
      <td> X2 </td>
      <td> - </td>
      <td>Extra fine portamento down</td>
    </tr>
    <tr>
      <td> 1F </td>
      <td> - </td>
      <td> - </td>
      <td> u </td>
      <td> - </td>
      <td>Volume column vibrato speed</td>
    </tr>
    <tr>
      <td> 20 </td>
      <td> - </td>
      <td> - </td>
      <td> h </td>
      <td> - </td>
      <td>Volume column vibrato depth</td>
    </tr>
    <tr>
      <td> 21 </td>
      <td> A </td>
      <td> A </td>
      <td> - </td>
      <td> - </td>
      <td>Set Speed</td>
    </tr>
    <tr>
      <td> 22 </td>
      <td> D </td>
      <td> D </td>
      <td> - </td>
      <td> - </td>
      <td>Volume Slide</td>
    </tr>
    <tr>
      <td> 23 </td>
      <td> E </td>
      <td> E </td>
      <td> - </td>
      <td> - </td>
      <td>Portamento Down (for formats without separate fine slides)</td>
    </tr>
    <tr>
      <td> 24 </td>
      <td> F </td>
      <td> F </td>
      <td> - </td>
      <td> - </td>
      <td>Portamento Up (for formats without separate fine slides)</td>
    </tr>
    <tr>
      <td> 25 </td>
      <td> I </td>
      <td> I </td>
      <td> - </td>
      <td> - </td>
      <td>Tremor</td>
    </tr>
    <tr>
      <td> 26 </td>
      <td> Q </td>
      <td> Q </td>
      <td> - </td>
      <td> - </td>
      <td>Retrigger Note</td>
    </tr>
    <tr>
      <td> 27 </td>
      <td> U </td>
      <td> U </td>
      <td> - </td>
      <td> - </td>
      <td>Fine Vibrato</td>
    </tr>
    <tr>
      <td> 28 </td>
      <td> M </td>
      <td> M </td>
      <td> - </td>
      <td> - </td>
      <td>Set Channel Volume</td>
    </tr>
    <tr>
      <td> 29 </td>
      <td> N </td>
      <td> N </td>
      <td> - </td>
      <td> - </td>
      <td>Channel Volume Slide</td>
    </tr>
    <tr>
      <td> 2A </td>
      <td> P </td>
      <td> P </td>
      <td> - </td>
      <td> - </td>
      <td>Panning Slide</td>
    </tr>
    <tr>
      <td> 2B </td>
      <td> S </td>
      <td> S </td>
      <td> - </td>
      <td> - </td>
      <td>S3M Multi-Purpose Command (Sxy)</td>
    </tr>
    <tr>
      <td> 2C </td>
      <td> T </td>
      <td> T </td>
      <td> - </td>
      <td> - </td>
      <td>Set Tempo</td>
    </tr>
    <tr>
      <td> 2D </td>
      <td> W </td>
      <td> W </td>
      <td> - </td>
      <td> - </td>
      <td>Global Volume Slide</td>
    </tr>
    <tr>
      <td> 2E </td>
      <td> Y </td>
      <td> Y </td>
      <td> Y </td>
      <td> - </td>
      <td>Panbrello</td>
    </tr>
    <tr>
      <td> 2F </td>
      <td> Z </td>
      <td> Z </td>
      <td> Z </td>
      <td> - </td>
      <td>MIDI Macro</td>
    </tr>
    <tr>
      <td> 30 </td>
      <td> a, b, c, d </td>
      <td> - </td>
      <td> - </td>
      <td> - </td>
      <td>Volume column combined volume slide command (values 0...9 = fine volume up, 10...19 = fine volume down, 20...29 = volume up, 30...39 = volume down) </td>
    </tr>
    <tr>
      <td> 31 </td>
      <td> e </td>
      <td> - </td>
      <td> - </td>
      <td> - </td>
      <td>Volume column portamento down</td>
    </tr>
    <tr>
      <td> 32 </td>
      <td> f </td>
      <td> - </td>
      <td> - </td>
      <td> - </td>
      <td>Volume column portamento up</td>
    </tr>
    <tr>
      <td> 33 </td>
      <td> - </td>
      <td> - </td>
      <td> W </td>
      <td> - </td>
      <td>Unused XM command "W", which can be used for syncing purposes.</td>
    </tr>
    <tr>
      <td> 34 </td>
      <td> * </td>
      <td> - </td>
      <td> - </td>
      <td> - </td>
      <td>Contains the original value of any unrecognized / non-standard IT volume column command. For example, OpenMPT's MPTM-exclusive volume column command oxx (Sample cue) is stored using this way (values 223...232 = o00 - o09).</td>
    </tr>
    <tr>
      <td> 35 </td>
      <td> # </td>
      <td> - </td>
      <td> # </td>
      <td> - </td>
      <td>OpenMPT's "Parameter Extension" command.</td>
    </tr>
    <tr>
      <td> 36 </td>
      <td> \ </td>
      <td> - </td>
      <td> \ </td>
      <td> - </td>
      <td>OpenMPT's "Smooth MIDI Macro" command. Similar to Zxx, but interpolates between the old and new Zxx / \xx parameter.</td>
    </tr>
    <tr>
      <td> 37 </td>
      <td> : </td>
      <td> - </td>
      <td> - </td>
      <td> - </td>
      <td>OpenMPT's "Delay Cut" (:xy). This command only exists in the MPTM format. It delays the note next to it for x ticks and then cuts it at x+y ticks.</td>
    </tr>
    <tr>
      <td> 38 </td>
      <td> + </td>
      <td> - </td>
      <td> - </td>
      <td> - </td>
      <td>OpenMPT's "Set Finetune" (+xy) command. Only supported in MPTM files.</td>
    </tr>
    <tr>
      <td> 39 </td>
      <td> * </td>
      <td> - </td>
      <td> - </td>
      <td> - </td>
      <td>OpenMPT's "Set Finetune (Smooth)" (*xy). Only supported in MPTM files.</td>
    </tr>

  </tbody>
</table>


One good example for MOD (almost all effects in a great music) is <a href="https://modarchive.org/module.php?36042">Danny
Elfmania</a> by <a href="http://www.elmobo.com">Moby</a><br/>

<br/>
Example (in hexa): 13 01 38 02 0d 0f 20<br/>
<p>
13 : 1 row of 3 type/value<br/>
01 38 : note is G#5<br/>
02 0d : instrument is 14<br/>
0f 20 : effect : C20
</p>

<p>Data for one voice is terminated with 00</p>

<h4>2.3.3 Instruments data</h4>


Instrument data takes 0x33a bytes, after the instrument name + filename (0
terminated)

<h5>Envelope Layout</h5>
Every instrument contains three envelopes, which follow this structure:
<table border="1" cellpadding="2">
  <tbody>
    <tr>
      <td> Address </td>
      <td> Length </td>
      <td> Type </td>
      <td> Description </td>
    </tr>
    
    <tr>
      <td> 0x0000 </td>
      <td> 1 </td>
      <td> byte </td>
      <td> Flags:
        <ul>
            <li>Bit 0 (0x01): Envelope enabled (IT, XM)</li>
            <li>Bit 1 (0x02): Sustain loop enabled (IT, XM)</li>
            <li>Bit 2 (0x04): Loop enabled (IT, XM)</li>
            <li>Bit 4 (0x10): Treat as filter envelope (only in the combined pitch/filter envelope, IT)</li>
            <li>Bit 5 (0x20): Envelope carry (IT)</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td> 0x0001 </td>
      <td> 1 </td>
      <td> byte </td>
      <td> Number of nodes </td>
    </tr>
    <tr>
      <td> 0x0002 </td>
      <td> 1 </td>
      <td> byte </td>
      <td> Sustain loop beginning (IT) / Sustain point (XM) </td>
    </tr>
    <tr>
      <td> 0x0003 </td>
      <td> 1 </td>
      <td> byte </td>
      <td> Sustain loop end (IT) / Ignore (XM) </td>
    </tr>
    <tr>
      <td> 0x0004 </td>
      <td> 1 </td>
      <td> byte </td>
      <td> Loop beginning </td>
    </tr>
    <tr>
      <td> 0x0005 </td>
      <td> 1 </td>
      <td> byte </td>
      <td> Loop end </td>
    </tr>
    <tr>
      <td> 0x0006 </td>
      <td> 25*2 </td>
      <td> short </td>
      <td> Envelope data, 25 nodes : position (short), value
0-&gt;64 (short) or 0-&gt;2048 (in case of the combined pitch / filter envelope)</td>
    </tr>
  </tbody>
</table>


<p>Instrument structure:</p>

<table border="1" cellpadding="2">
  <tbody>
    <tr>
      <td> Address </td>
      <td> Length </td>
      <td> Type </td>
      <td> Description </td>
    </tr>
    <tr>
      <td> </td>
      <td> variable </td>
      <td> char[] </td>
      <td> instrument name (0 terminated) </td>
    </tr>
    <tr>
      <td> </td>
      <td> variable </td>
      <td> char[] </td>
      <td> instrument filename (0 terminated) - Only if version &ge; 5, otherwise not included </td>
    </tr>
    <tr>
      <td> 0x0000 </td>
      <td> 1 </td>
      <td> long </td>
      <td>flags :&nbsp;1 = play on MIDI, 2 = mute. These are
hardly ever used </td>
    </tr>
    <tr>
      <td> 0x0004 </td>
      <td> 10*12*2 </td>
      <td> short </td>
      <td> sample map : 10 octaves * 12 notes * 4 bytes<br/>IT: first short = note [ignore in XM!],
second short = sample number). In XM, the first 96 values of the sample map are used, the remaining 24 are ignored.</td>
    </tr>
    <tr>
      <td> 0x01e4 </td>
      <td> 106 </td>
      <td> Envelope </td>
      <td> Volume Envelope </td>
    </tr>
    <tr>
      <td> 0x024e </td>
      <td> 106 </td>
      <td> Envelope </td>
      <td> Panning Envelope </td>
    </tr>
    <tr>
      <td> 0x02b8 </td>
      <td> 106 </td>
      <td> Envelope </td>
      <td> Combined Pitch / Filter Envelope </td>
    </tr>
    <tr>
      <td> 0x0322 </td>
      <td> 1 </td>
      <td> byte </td>
      <td> Vibrato Type (0=sine, 1=Ramp down, 2=square, 3=random) (XM only)
      </td>
    </tr>
    <tr>
      <td> 0x0323 </td>
      <td> 1 </td>
      <td> byte </td>
      <td> Vibrato Sweep (XM only) </td>
    </tr>
    <tr>
      <td> 0x0324 </td>
      <td> 1 </td>
      <td> byte </td>
      <td> Vibrato Depth (XM only) </td>
    </tr>
    <tr>
      <td> 0x0325 </td>
      <td> 1 </td>
      <td> byte </td>
      <td> Vibrato Rate (XM only) </td>
    </tr>
    <tr>
      <td> 0x0326 </td>
      <td> 1 </td>
      <td> short </td>
      <td> Fade Out (in XM precision, so divide by 32 for IT)</td>
    </tr>
    <tr>
      <td> 0x0328 </td>
      <td> 1 </td>
      <td> byte </td>
      <td> MIDI Channel </td>
    </tr>
    <tr>
      <td> 0x0329 </td>
      <td> 1 </td>
      <td> byte </td>
      <td> MIDI Bank </td>
    </tr>
    <tr>
      <td> 0x032a </td>
      <td> 1 </td>
      <td> byte </td>
      <td> MIDI Patch </td>
    </tr>
    <tr>
      <td> 0x032b </td>
      <td> 1 </td>
      <td> byte </td>
      <td> MIDI Bend (for IT files, this contains the "PWD" IT header value starting from MO3 2.4.1.2) </td>
    </tr>
    <tr>
      <td> 0x032c </td>
      <td> 1 </td>
      <td> byte </td>
      <td> Global Volume (0...128, IT only) </td>
    </tr>
    <tr>
      <td> 0x032d </td>
      <td> 1 </td>
      <td> short </td>
      <td> Panning (0...256 if enabled, 0xFFFF otherwise) </td>
    </tr>
    <tr>
      <td> 0x032f </td>
      <td> 1 </td>
      <td> byte </td>
      <td> New Note Action [IT] </td>
    </tr>
    <tr>
      <td> 0x0330 </td>
      <td> 1 </td>
      <td> byte </td>
      <td> Pitch Pan Separation [IT] </td>
    </tr>
    <tr>
      <td> 0x0331 </td>
      <td> 1 </td>
      <td> byte </td>
      <td> Pitch Pan Center [IT] </td>
    </tr>
    <tr>
      <td> 0x0332 </td>
      <td> 1 </td>
      <td> byte </td>
      <td> Duplicate Check Type [IT] </td>
    </tr>
    <tr>
      <td> 0x0333 </td>
      <td> 1 </td>
      <td> byte </td>
      <td> Duplicate Check Action [IT] </td>
    </tr>
    <tr>
      <td> 0x0334 </td>
      <td> 1 </td>
      <td> short </td>
      <td> Volume Swing (0...100) [IT] </td>
    </tr>
    <tr>
      <td> 0x0336 </td>
      <td> 1 </td>
      <td> short </td>
      <td> Pan Swing (0...256) [IT] </td>
    </tr>
    <tr>
      <td> 0x0338 </td>
      <td> 1 </td>
      <td> byte </td>
      <td> Initial Filter Cutoff (0...127, +128 if enabled) [IT] </td>
    </tr>
    <tr>
      <td> 0x0339 </td>
      <td> 1 </td>
      <td> byte </td>
      <td> Initial Filter Resonance (0...127, +128 if enabled) [IT] </td>
    </tr>
  
  </tbody>
</table>

<p>The number of sample for given instrument is deducted from the sample map.
</p>


<h4>2.3.4 Samples data</h4>

Samples data takes 0x29 bytes after the sample name / filename
(0x2B if some flags are set, see below), which is 0 terminated.
<table border="1" cellpadding="2">
  <tbody>
    <tr>
      <td> Address </td>
      <td> Length </td>
      <td> Type </td>
      <td> Description </td>
    </tr>
    <tr>
      <td> </td>
      <td> variable </td>
      <td> char[] </td>
      <td> Sample Name (0 terminated)<br/>

       </td>
    </tr>
    <tr>
      <td> </td>
      <td> variable </td>
      <td> char[] </td>
      <td> Sample Filename (0 terminated) - Only if version &ge; 5, otherwise not included 
    </tr>
    <tr>
      <td> 0x0000 </td>
      <td> 1 </td>
      <td> long </td>
      <td> Finetune (signed char -128...127 like in XM, but with MOD/XM the "center" value is at 0x80, with MTM it's 0x00. MTM also seems to have the lowest bit of the second byte set for some reason, but it can be ignored.) [MOD, XM, MTM]<br/>
        or "C4/5 speed" (sample rate) for S3M and IT. Sample rate is in Hertz if version &ge; 5 or linear slides are disabled, otherwise it can be computed as follows: sampleRate = 8363.0 * pow(2.0, (Finetune + 1408) / 1536.0)</td>
    </tr>
    <tr>
      <td> 0x0004 </td>
      <td> 1 </td>
      <td> byte </td>
      <td> Transpose (-128... 127)</td>
    </tr>
    <tr>
      <td> 0x0005 </td>
      <td> 1 </td>
      <td> byte </td>
      <td> Default Volume (0...64) </td>
    </tr>
    <tr>
      <td> 0x0006 </td>
      <td> 1 </td>
      <td> short </td>
      <td> Panning (0...256 if enabled, 0xFFFF otherwise) </td>
    </tr>
    <tr>
      <td> 0x0008 </td>
      <td> 1 </td>
      <td> long </td>
      <td> Sample length in sampling points<br/>
if size==0 and end!=0 : means removed sample (not used) </td>
    </tr>
    <tr>
      <td> 0x000c </td>
      <td> 1 </td>
      <td> long </td>
      <td> Loop Start </td>
    </tr>
    <tr>
      <td> 0x0010 </td>
      <td> 1 </td>
      <td> long </td>
      <td> Loop End </td>
    </tr>
    <tr>
      <td> 0x0014 </td>
      <td> 1 </td>
      <td> short </td>
      <td> Flags<br/>
        <ul>
          <li>Bit 0 (0x01): 16-bit sample (8-bit otherwise)</li>
          <li>Bit 4 (0x10): Sample loop enabled</li>
          <li>Bit 5 (0x20): Ping-pong loop (set together with 0x10)</li>
          <li>Bit 8 (0x100): Sustain loop enabled</li>
          <li>Bit 9 (0x200): Ping-pong sustain loop (set together with 0x100)</li>
          <li>Bit 10 (0x400): Stereo sample</li>
          <li>Bit 12 (0x1000): 1=lossy compression (MPEG 1.0 / 2.0 / 2.5, together with bit#13 (0x3000) means Ogg, together with bit#13/14 (0x7000) means Ogg with shared Vorbis header)</li>
          <li>Bit 13 (0x2000): lossless compression 'delta' (with bit#12 cleared)</li>
          <li>Bit 14 (0x4000): lossless compression 'delta prediction'</li>
          <li>Bit 15 (0x8000): OPL patch data (S3M / MPTM)</li>
        </ul>
        If none of the compression flags (0x1000, 0x2000, 0x4000, 0x8000) are set, the sample is not compressed at all, i.e. stored as normal signed integer PCM data.
      </td>
    </tr>
    <tr>
      <td> 0x0016 </td>
      <td> 1 </td>
      <td> byte </td>
      <td> Vibrato type (0=sine, 1=ramp down, 2=square, 3=random) [IT] </td>

    </tr>
    <tr>
      <td> 0x0017 </td>
      <td> 1 </td>
      <td> byte </td>
      <td> Vibrato Sweep [IT] </td>
    </tr>
    <tr>
      <td> 0x0018 </td>
      <td> 1 </td>
      <td> byte </td>
      <td> Vibrato Depth [IT] </td>
    </tr>
    <tr>
      <td> 0x0019 </td>
      <td> 1 </td>
      <td> byte </td>
      <td> Vibrato Rate [IT] </td>
    </tr>
    <tr>
      <td> 0x001a </td>
      <td> 1 </td>
      <td> byte </td>
      <td> Global Volume [IT] </td>
    </tr>
    <tr>
      <td> 0x001b </td>
      <td> 1 </td>
      <td> long </td>
      <td> Sustain Loop Start [IT] </td>
    </tr>
    <tr>
      <td> 0x001f </td>
      <td> 1 </td>
      <td> long </td>
      <td> Sustain Loop End [IT] </td>
    </tr>
    <tr>
      <td> 0x0023 </td>
      <td> 1 </td>
      <td> long </td>
      <td> Compressed Size. If it is negative, this is a copy of a previous sample (-1 is the previous sample, -2 the sample before that, etc.). </td>
    </tr>
    <tr>
      <td> 0x0027 </td>
      <td> 1 </td>
      <td> short </td>
      <td> MP3: Encoder Delay in bytes. This also includes the samples cut off by LAME's gapless header! Note that the byte value assumes that the decoded sample has 16-bit quality, i.e. to convert it to samples, divide it by 2 (or 4 for stereo samples). See section 3.1 for practical hints on LAME headers.<br/>
           Ogg: If shared headers are used, this is the header size (i.e. read as many bytes from the other sample's data and then append the current sample's data).</td>
    </tr>
    <tr>
      <td> 0x0029 </td>
      <td> 1 </td>
      <td> short </td>
      <td> Starting from format version 5, Ogg-encoded samples can share their headers to reduce size even further. This field is only present if version &ge; 5 and flag bits 12 and 14 (0x1000 | 0x4000) are set. In this case, the short indicates which sample the Ogg header is taken from. This is a signed value, and headers can be taken from both previous and follow-up samples. </td>
    </tr>
  
  </tbody>
</table>

<p>Note that for OPL (AdLib) instruments, the sample length is 0, bit 15 (0x8000) of the flags is set and the compressed size indicates the size of the OPL patch (12 bytes for OPL2 patches). OPL patches are stored uncompressed, the same way as in S3M and MPTM files.</p>


<h3>2.4 Plugins</h3>

<p>If the plugin flag is set in the header, plugin data follows:</p>

<p>The first byte determines if plugin to channel mappings follow. If the byte is
1, read a long for every channel. If it is 0, no plugin is assinged to this
channel, if it is 1, the first plugin is assigned, etc.
Afterwards the plugin data follows.</p>
<p>A byte indicates for which plugin it is (0 = none, 1 = first plugin, etc.)
and a long determines the data size.
This data follows the OpenMPT plugin information as it can be found in IT, XM
and MPTM files (<a href="https://wiki.openmpt.org/Development:_OpenMPT_Format_Extensions#FX00.2C_..._FX99.2C_F100.2C_..._F255">FX00, FX01, ... chunks</a>).</p>

<h3>2.5 Misc chunks</h3>

<p>After the plugin data (or after the sample headers if the plugin flag is not
set), some miscellaneous chunks may be found in format version 5 upwards.
Support for these chunks was added in MO3 2.4.1, released in January 2016.</p>

<p>The chunk layout is as follows:</p>

<table border="1" cellpadding="2">
  <tbody>
    <tr>
      <td> Address </td>
      <td> Length </td>
      <td> Type </td>
      <td> Description </td>
    </tr>
    <tr>
      <td> 0 </td>
      <td> 4 </td>
      <td> char[4] </td>
      <td> Chunk ID </td>
    </tr>
    <tr>
      <td> 4 </td>
      <td> 4 </td>
      <td> long </td>
      <td> Chunk size </td>
    </tr>
    <tr>
      <td> 8 </td>
      <td> computed </td>
      <td> byte[] </td>
      <td> Chunk content (size specified by previous field) </td>
    </tr>
  </tbody>
</table>

<p>The following chunk IDs are currently used:</p>

<ul>
<li> <code>VERS</code>: Original version information from the source file, which
     can be helpful when figuring out how to play a file (i.e. emulate quirks of
     the tracker that was used to create the original file).
     For XM files, it contains the tracker identification string (only if it was
     not "FastTracker v2.00"), for MTM files the version byte from the header,
     and for S3M / IT files the original Cwt/v (and Cmwt in case of IT) header
     values.<br/>
     This is the only reliable way to distinguish between IT and MPTM files:
     If 0x0889 &le; Cwt/v &le; 0x8FF, the original file was an MPTM file rather
     than an IT file.</li> 

<li> <code>PRHI</code>: Pattern row highlight information from the IT header.</li> 

<li> <code>MIDI</code>: Full MIDI macro configuration (same chunk
     layout as in IT), in case it cannot be expressed completely through MO3's
     condensed version in the header above.</li> 

<li> <code>OMPT</code>: All of OpenMPT's MPTM/IT/XM extensions.<br/>
     This chunk may contain the following data in the given order:
     <ul>
     <li> <code>PNAM</code>: Pattern names. Followed by a long indicating the
          length of the following pattern name data. Names are stored with a
          fixed width of 32 characters (each name itself may be null-terminated
          if it is shorter than 32 characters). This implies that there are
          (length / 32) pattern names in the chunk.</li>
     <li> <code>CNAM</code>: Channel names. Works exactly like pattern names,
          with the difference that channel names are only 20 characters long.</li>
     <li> <code>XTPM</code>: <a href="https://wiki.openmpt.org/Development:_OpenMPT_Format_Extensions#OpenMPT_Instrument_Extensions">
          OpenMPT Instrument Extensions</a>. Same format as in OpenMPT-made files.
     <li> <code>STPM</code>: <a href="https://wiki.openmpt.org/Development:_OpenMPT_Format_Extensions#OpenMPT_Song_Extensions">
          OpenMPT Song Extensions</a>. Same format as in OpenMPT-made files.
     <li> <code>228</code>: <a href="https://wiki.openmpt.org/Development:_228_Extensions">
          OpenMPT MPTM extensions</a>. Same format as in
          OpenMPT-made files. These only follow if the original file was an MPTM
          file.
     </ul>
</li> 
</ul>


<h2>3. Samples</h2>


<p>The samples lossless algorithms are <a href="https://github.com/lclevy/unmo3">here</a>
(mo3_unpack.c).</p>


<p>There is one version for 8 bit samples and another one for 16 bit samples.</p>


<p>There are two lossless algorithms: One based on delta encoding
(as in <a href="xm.txt">xm</a>), a second one based on delta prediction
encoding. Then these delta values are stored in a compact way.</p>

<h3>3.1 Practical hints</h3>

<p>Special care has to be taken of MPEG samples:
MO3 files created with recent versions of the MO3 encoder will not contain LAME
headers with gapless information, in this case the sample just needs to be
decoded and the encoder delay must be removed afterwards.
However, older MO3 files may contain LAME info frames including gapless
information.
In this case you have three options:
</p>
<ul>
<li>Detect if a LAME info frame is present (i.e. parse the first MPEG frame) and
compute the frame's length in samples
(<a href="https://source.openmpt.org/browse/openmpt/trunk/OpenMPT/soundlib/MPEGFrame.cpp">example code</a>).
Subtract the length from the encoder delay and do not feed this frame into the
MPEG decoder. This is the most stable solution, as it is independent of the MPEG
decoder's capabilities, so it can be used with Windows' ACM or Media Foundation
codecs.</li>
<li>Detect if a LAME info frame is present (i.e. parse the first MPEG frame) and
let the decoder handle the LAME header (don't apply MO3's encoder delay
information at all).</li>
<li>Instruct your MPEG decoder to ignore the LAME info frame (in case of
libmpg123, you can set the MPG123_IGNORE_INFOFRAME flag in recent versions) and
apply the encoder delay yourself.</li>
</ul>

<p>Depending on the Ogg decoder, special care has to be taken of Ogg samples with
shared headers: Every Ogg stream has a unique ID, and this ID has to be
identical for all frames of the stream. Some decoders like
<a href="https://github.com/nothings/stb/blob/master/stb_vorbis.c">stb_vorbis</a>
do not care about this at all, so you can just stitch the Ogg stream together
from the shared samples. libvorbis, on the other hand, requires the shared
header to be modified so that it uses the same unique ID as the rest of the
sample stream.


<h2>4. Source code</h2>


The source code version 0.6 is available <a href="https://github.com/lclevy/unmo3">here</a>.
Here is an extract of the 'readme' file:
<p>"The piece of code has been written as a compagnion
(validation code) of the document "the unofficial MO3 specification".
</p>


<p>It is targeted towards developers or technical people, not for end
users. It can be used by IT/XM/S3M modules
specialists (tracker editor developer or modules players) to write a
MO3 import loader, or more generally to handle MO3 modules in any way.
</p>


<p>The MO3 format has been created by Ian Luck
(<a href="https://www.un4seen.com/">https://www.un4seen.com/</a>).
If you are looking for a good encoder and decoder (but without the
source code) and a good module player,
Ian's web site is the right place to go. </p>


<p>The features of unmo3 (opensource version) are:
</p>


<ul>


  <li> uncompress the MO3 header and samples with lossless
compressions. </li>
  <li> able to save to a file uncompressed header and samples </li>
  <li> able to extract mp3 and ogg compressed samples </li>
  <li> can display a channel of a given pattern into 2 forms
    <ul>
      <li> as encoded inside MO3 file </li>
      <li> as it usually appears in a tracker editor (for .mod only) </li>
    </ul>
  </li>

</ul>


<p>You can see output of the 'demo' <a href="demo.txt">here</a>
and the auto tests <a href="test.txt">here</a>.
For tests, a second archive '<a href="unmo3_test.zip">unmo3_test.zip</a>'
is required (has to be uncompressed in the same place as the 'unmo3_src.zip' archive).
</p>
The Win32 binary is here <a href="unmo3.exe">unmo3.exe</a>.

<h3>5. Other information</h3>


The unmo3 Win32 executable is compressed with <a href="https://www.un4seen.com/petite/">PEtite</a>, and the
Linux executable with <a href="https://upx.github.io/">UPX</a>.
<p>
Other modules file formats are available here (from <a href="http://www.wotsit.org">Wotsit</a>):
</p>


<ul>
  <li><a href="mod.txt">mod</a> </li>
  <li><a href="xm.txt">xm</a> <a href="xm_errata.txt">corrections</a> </li>
  <li><a href="mtm.txt">mtm</a> <a href="mtm-efx.txt">doc</a> </li>
  <li><a href="it.txt">it</a> </li>
  <li><a href="s3m.txt">s3m</a> </li>
</ul>


<p>Previous work on Amiga module compression is available <a href="http://membres.lycos.fr/asle/ampd.html">here</a>
(Sylvain Chipaux and Gryzor).<br/>
You can find on <a href="http://lclevy.free.fr/exotica">Exotica</a>
a huge collection of Amiga music formats descriptions.
</p>


<p>State of the art waveform compression is explained here : <a href="http://www.true-audio.com/codec.theory">TTA</a>,
<a href="http://citeseer.ist.psu.edu/robinson94shorten.html">Shorten</a>,
<a href="http://www.hpl.hp.com/techreports/1999/HPL-1999-144.pdf%20">AudioPak</a>,
and <a href="https://xiph.org/flac/">FLAC</a>.
</p>


<ul>
<li><a href="https://lib.openmpt.org/">libopenmpt</a> can play a wide range of
  module formats. It is the first module library with native decoding of MO3,
  which was made possible by this document.</li>
<li><a href="https://github.com/kode54/dumb/">DUMB</a>
  is a free opensource library to replay XM, IT, MOD, S3M and other modules.</li>
<li><a href="https://github.com/cmatsuoka/libxmp/">XMP</a> is a portable and
  open-source module player.</li>
</ul>

<p>-end of the document-
</p>


</body>
</html>
